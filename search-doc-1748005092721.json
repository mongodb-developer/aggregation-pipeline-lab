{"searchDocs":[{"title":"üëê Group","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/grouping/group","content":"üëê Group We can sum all the pages for all books in each year: Atlas UIMongoDB Shell [ {$group:{ _id: &quot;$year&quot;, totalPages: {$sum: &quot;$pages&quot;} }} ] Here, we group by the book's year (the _id of the grouping), and then we create a new field called totalPages that's the sum of all pages. üëê Can you get the results ordered ascending by year? Answer Atlas UIMongoDB Shell [ {$group:{ _id: &quot;$year&quot;, totalPages: {$sum: &quot;$pages&quot;} }}, {$sort: {_id: 1}} ] üëê Can you get the average pages per year (hint: use $avg)? Answer Atlas UIMongoDB Shell [ {$group:{ _id: &quot;$year&quot;, totalPages: {$avg: &quot;$pages&quot;} }}, {$sort: {_id: 1}} ] üëê Which year had the most printed-out pages? Answer Atlas UIMongoDB Shell [ {$group:{ _id: &quot;$year&quot;, totalPages: {$sum: &quot;$pages&quot;} }}, {$sort: {totalPages: -1}}, {$limit: 1} ] ","keywords":"","version":"Next"},{"title":"ü¶∏ Saving to a Collection","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/exporting-data/saving-to-collection","content":"","keywords":"","version":"Next"},{"title":"Merging output results‚Äã","type":1,"pageTitle":"ü¶∏ Saving to a Collection","url":"/aggregation-pipeline-lab/docs/exporting-data/saving-to-collection#merging-output-results","content":" If the collection specified by the $out operation already exists, then the $out stage atomically replaces the existing collection with the new results collection upon completion of the aggregation.  To avoid overwriting the existing collection we can use $merge instead of $out.  { $merge : { into : &quot;newCollection&quot; } }   if the collection does not exists, it will be createdif it exists, new data will be addedif a doc already exists, we can replace it, keep the existing one, merge both documents cause the stage to fail or run a pipeline.  This is perfect for creating On-Demand Materialized Views  As an example, let's say we want the authors to contain all the books they've written, with all the book information. In this case, we'll do a $lookup to get the book information into the authors collection. We can even use the name books for the resulting data we're joining, shadowing the original books array we have in authors. This way it will look like the books array changes.  [ {$lookup: { from: &quot;books&quot;, localField: &quot;books&quot;, foreignField: &quot;_id&quot;, as: &quot;books&quot; } }, ]   Now a book will look like this. You can see that the books array has been &quot;overwritten&quot; by the $lookup.  { &quot;name&quot;: &quot;Richard Bruce Wright&quot;, &quot;sanitizedName&quot;: &quot;richardbrucewright&quot;, &quot;books&quot;: [ { &quot;_id&quot;: &quot;0002005018&quot;, &quot;title&quot;: &quot;Clara Callan: A novel&quot;, &quot;authors&quot;: [ { &quot;_id&quot;: { &quot;$oid&quot;: &quot;64cc2db4830ba29148da4c3b&quot; }, &quot;name&quot;: &quot;Richard Bruce Wright&quot; } ], &quot;genres&quot;: [ &quot;Women Teachers&quot;, &quot;Young Women&quot;, &quot;Actresses&quot;, &quot;Sisters&quot; ], &quot;pages&quot;: 414, &quot;year&quot;: 2001, &quot;synopsis&quot;: &quot;Giller Prize Winner 2001. Richard B. Wright. A Phyllis Bruce Book.&quot;, &quot;cover&quot;: &quot;https://images.isbndb.com/covers/50/12/9780002005012.jpg&quot;, &quot;attributes&quot;: [ { &quot;key&quot;: &quot;edition&quot;, &quot;value&quot;: &quot;1st&quot; }, { &quot;key&quot;: &quot;dimensions&quot;, &quot;value&quot;: &quot;Height: 11.11 Inches, Length: 6.11 Inches, Weight: 1 Pounds, Width: 1.11 Inches&quot; }, { &quot;key&quot;: &quot;isbn13&quot;, &quot;value&quot;: &quot;9780002005012&quot; }, { &quot;key&quot;: &quot;msrp&quot;, &quot;value&quot;: &quot;0.00&quot; }, { &quot;key&quot;: &quot;isbn&quot;, &quot;value&quot;: &quot;0002005018&quot; }, { &quot;key&quot;: &quot;isbn10&quot;, &quot;value&quot;: &quot;0002005018&quot; } ], &quot;totalInventory&quot;: 2, &quot;available&quot;: 3, &quot;binding&quot;: &quot;Hardcover&quot;, &quot;language&quot;: &quot;en&quot;, &quot;publisher&quot;: &quot;HarperFlamingoCanada&quot;, &quot;longTitle&quot;: &quot;Clara Callan: A novel&quot;, &quot;reviews&quot;: [ { &quot;_id&quot;: { &quot;$oid&quot;: &quot;678900bc99a40f049f32d0be&quot; }, &quot;text&quot;: &quot;bbb&quot;, &quot;name&quot;: &quot;Tawdry Lemur&quot;, &quot;rating&quot;: 5, &quot;timestamp&quot;: 1737031868630 }, { &quot;_id&quot;: { &quot;$oid&quot;: &quot;672231e138e1f3e7c1c1c1cf&quot; }, &quot;text&quot;: &quot;testss&quot;, &quot;name&quot;: &quot;Brash Iguana&quot;, &quot;rating&quot;: 4, &quot;timestamp&quot;: 1730294241948 }, { &quot;_id&quot;: { &quot;$oid&quot;: &quot;6719acf4232c1a1deb2cbd7c&quot; }, &quot;text&quot;: &quot;hi&quot;, &quot;name&quot;: &quot;Brash Rhino&quot;, &quot;rating&quot;: 5, &quot;timestamp&quot;: 1729735924953 }, { &quot;_id&quot;: { &quot;$oid&quot;: &quot;6719ace0232c1a1deb2cbd7b&quot; }, &quot;text&quot;: &quot;good&quot;, &quot;name&quot;: &quot;Killer Alligator&quot;, &quot;rating&quot;: 3, &quot;timestamp&quot;: 1729735904188 }, { &quot;_id&quot;: { &quot;$oid&quot;: &quot;6719acdd232c1a1deb2cbd7a&quot; }, &quot;text&quot;: &quot;good&quot;, &quot;name&quot;: &quot;Killer Alligator&quot;, &quot;rating&quot;: 5, &quot;timestamp&quot;: 1729735901895 } ] } ], &quot;aliases&quot;: [ &quot;Wright, Richard Bruce&quot; ] }   We can go ahead and remove the authors from the books array, as it is redundant:  [ {$lookup: { from: &quot;books&quot;, localField: &quot;books&quot;, foreignField: &quot;_id&quot;, as: &quot;books&quot; } }, {$unset: 'books.authors'}, ]   Now that our authors look the way we want, we can overwrite the authors collection using $merge  [ {$lookup: { from: &quot;books&quot;, localField: &quot;books&quot;, foreignField: &quot;_id&quot;, as: &quot;books&quot; } }, {$unset: 'books.authors'}, {$merge: { into: 'authors', on: '_id', whenMatched: 'replace', }} ]   we use the _id field to match documentswe replace the existing ones with replace  warning We should see a message telling us that the $merge operator will cause the pipeline to persist the results to the specified location. This stage changes data. ","version":"Next","tagName":"h2"},{"title":"Intro","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/intro","content":"Intro Lab goals\tLearn about aggregation pipelines writing aggregation pipelinesWhat you'll learn\tWhat are aggregation pipelines? How are they different from simple MongoDB queries or SQL? How to use simple pipelines to get data, filter it, show the fields needed How to write more advanced pipelines, querying arrays, counting and sorting results How to do JOINs using $lookup How to group data Exporting data How to write aggregations using popular programming languages (TBD) Time to complete\t90 mins In the navigation bar and on some pages, you will notice some icons. Here are their meanings: Icon\tMeaningüìò\tLecture material - If you're following along in an instructor-led session, they probably have covered this already. üëê\tHands-on content - Get ready to get some work done. You should follow these steps. üí¨\tDiscussion - Item to discuss during the lab ü¶∏\tAdvanced content - This content isn't covered during the lab, but if you're interested in learning more, you can check it out.","keywords":"","version":"Next"},{"title":"üëê $count","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/counting-sorting/counting-documents","content":"","keywords":"","version":"Next"},{"title":"The order of stages is important‚Äã","type":1,"pageTitle":"üëê $count","url":"/aggregation-pipeline-lab/docs/counting-sorting/counting-documents#the-order-of-stages-is-important","content":" If we count after the $match stage, the document we're passing to the next steps contains only the totalBooks field. So the $project stage will return an empty document.  Atlas UIMongoDB ShellJavascript [ {$match: {$and: [{year: 1985}, {pages: {$gte: 150}} ]}}, {$count: &quot;totalBooks&quot;}, {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}, {$limit: 15}, ]  ","version":"Next","tagName":"h2"},{"title":"üëê Sorting","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/counting-sorting/sorting","content":"üëê Sorting We can sort our results using the $sort stage. We need to sort on a field, with 1 being ascending and -1 descending order. üëê Let's get all books from 1984, sorted by number of pages. We'll only show the title, pages, and authors. Atlas UIMongoDB Shell [ {$match: {year: 1984}}, {$project: {_id: 0, title: 1, pages: 1, authors: 1}}, {$sort: {&quot;pages&quot;: 1}}, ] As we can see, books with no pages info appear first. These documents don't have that information. Hence, pages is null and gets sorted as less than any number. üëê We can sort the other way around: Atlas UIMongoDB Shell [ {$match: {year: 1984}}, {$project: {_id: 0, title: 1, pages: 1, authors: 1}}, {$sort: {&quot;pages&quot;: -1}}, ] üëê How can we get the thickest book from 1984? Answer Atlas UIMongoDB Shell [ {$match: {year: 1984}}, {$project: {_id: 0, title: 1, pages: 1, authors: 1}}, {$sort: {&quot;pages&quot;: -1}}, {$limit: 1} ] ","keywords":"","version":"Next"},{"title":"üìò Lecture material","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/lecture-material","content":"","keywords":"","version":"Next"},{"title":"Aggregation pipeline cheatsheet‚Äã","type":1,"pageTitle":"üìò Lecture material","url":"/aggregation-pipeline-lab/docs/lecture-material#aggregation-pipeline-cheatsheet","content":"   Unable to display PDF file. Download instead. ","version":"Next","tagName":"h2"},{"title":"ü¶∏ Missing Data","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/modifying-results/missing-data","content":"ü¶∏ Missing Data Sometimes, we're missing a field we're looking for (it's not there, as documents in a collection can be polymorphic, so this field is null). For these cases, we can check if something is there using $ifNull and add a default value. Atlas UIMongoDB Shell [ { $project: { name: 1, books: { $ifNull: [&quot;$books&quot;, []]}, } } ] ","keywords":"","version":"Next"},{"title":"ü¶∏‚Äç‚ôÇÔ∏è Advanced lookups","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/lookups/advanced-lookups","content":"ü¶∏‚Äç‚ôÇÔ∏è Advanced lookups info Extra activity! Do it if you have extra time or are following along at home. It won't be covered during the hands-on lab. We get this request: Write a $lookup to get name and bio from author's information inside each book document. To get this done, we need to review several things: Each book can have several authors. This many-to-many relationship (as an author can also write many books) is modeled using two different arrays: a books array in the authors collection and an authors array in the books collection.So we'll need to get a separate document for each book that has more than one author. If a book has three authors, we'll use $unwind to get three documents with the same data except for the author, which will be each of the three authors. You can try this with this aggregation pipeline: Atlas UIMongoDB Shell [ // as a book can have many authors, we get one doc per book's author {$unwind: &quot;$authors&quot;}, // remove some noisy fields {$project: {attributes: 0, reviews: 0}} ] Now, we need to get the authors' information. For that, we'll use $lookup, linking the _id in the authors collection with the _id we have in each book's authors array. But as we can see here, these have a different type: The ones inside our array are strings, while the author collection _id are ObjectId. authors: { _id: '64cc2db4830ba29148da64a2', name: 'Timothy Findley' }, So we need to convert from String into ObjectId. We can do that using $toObjectId. This will add a new field, authorId, converting it into ObjectId: Atlas UIMongoDB Shell [ // as a book can have many authors, we get one doc per book's author {$unwind: &quot;$authors&quot;}, // convert it to an objectId {&quot;$set&quot;:{&quot;authorId&quot;:{&quot;$toObjectId&quot;:&quot;$authors._id&quot;}}}, // remove some noisy fields {$project: {attributes: 0, reviews: 0}} ] Now, we're ready to do the $lookup: We want all documents from authors that have the same _id as the authorId we just created. We use a pipeline to get just authors name and bio. Atlas UIMongoDB Shell [ // as a book can have many authors, we get one doc per book's author {$unwind: &quot;$authors&quot;}, // convert it to an objectId {&quot;$set&quot;:{&quot;authorId&quot;:{&quot;$toObjectId&quot;:&quot;$authors._id&quot;}}}, {$lookup: { from: &quot;authors&quot;, localField: &quot;authorId&quot;, foreignField: &quot;_id&quot;, pipeline: [ {$project: {name: 1, bio: 1}}, ], as: &quot;bookAuthorDetails&quot; } }, // remove some noisy fields {$project: {attributes: 0, reviews: 0}} ] ","keywords":"","version":"Next"},{"title":"üëê Lookups, AKA Left Outer Join","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/lookups/lookups","content":"","keywords":"","version":"Next"},{"title":"Lookups from a previous stage‚Äã","type":1,"pageTitle":"üëê Lookups, AKA Left Outer Join","url":"/aggregation-pipeline-lab/docs/lookups/lookups#lookups-from-a-previous-stage","content":" We can do a $lookup on the result of another pipeline, not only joining with a collection. For instance, we want to remove some noise from the books before joining, so we use $project to exclude a couple of arrays.  Atlas UIMongoDB Shell [ {$lookup: { from: &quot;books&quot;, localField: &quot;books&quot;, foreignField: &quot;_id&quot;, pipeline: [ {$project: {title: 1, synopsis: 1}} ], as: &quot;booksWritten&quot; } } ]   The nice part is that we can extract that pipeline and test it/tweak it. (This will only work in the MongoDB Shell)  MongoDB Shell let justShowTitleSynopsis = [ {$project: {title: 1, synopsis: 1}}, ] db.authors.aggregate([ {$lookup: { from: &quot;books&quot;, localField: &quot;books&quot;, foreignField: &quot;_id&quot;, pipeline: justShowTitleSynopsis, as: &quot;booksWritten&quot; } } ])  ","version":"Next","tagName":"h2"},{"title":"üëê Adding New Fields to Results","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/modifying-results/adding-fields","content":"","keywords":"","version":"Next"},{"title":"$set / $addFields‚Äã","type":1,"pageTitle":"üëê Adding New Fields to Results","url":"/aggregation-pipeline-lab/docs/modifying-results/adding-fields#set--addfields","content":" We want to estimate the reading time for a book. But we don't have that field stored in our data. We can use $set for this. If the field exists, it'll get updated, and if it doesn't, it's added.  Atlas UIMongoDB Shell [ {$project: { title: 1, pages: 1, } }, {$set: {readingTimeHours: {$divide: [{$multiply: [&quot;$pages&quot;, 2]}, 60]}}}, ]   üëê Add a new field, notes, that contains the text PLACEHOLDER for all documents.  Answer Atlas UIMongoDB Shell [ {$project: { title: 1, pages: 1, } }, {$set: {notes: &quot;PLACEHOLDER&quot;}} ]   info $set is a new alias for $addFields. You'll still find $addFields on many older posts and documentation. ","version":"Next","tagName":"h2"},{"title":"ü¶∏‚Äç‚ôÇÔ∏è Aggregation options","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/aggregation-options","content":"ü¶∏‚Äç‚ôÇÔ∏è Aggregation options info Extra activity! Do it if you have extra time or are following along at home. It won't be covered during the hands-on lab. danger The following syntax doesn't work in the Atlas UI aggregations editor. The editor doesn't support declaring variables. You can try this using the built-in MongoDB Shell in MongoDB Compass. We can pass a document to aggregate with some options. MongoDB Shell let options = { maxTimeMS: 100 }; db.authors.aggregate([], options); üíª Have a look at the different options you can pass to the aggregate method. üíª Try to launch an itcount (a long operation) to iterate through the whole books cursor with a time limit of 10 ms. You should see the operation timing out and failing. MongoDB Shell let options = { maxTimeMS: 10 }; db.authors.aggregate([], options).itcount(); &gt; MongoServerError: operation exceeded time limit ","keywords":"","version":"Next"},{"title":"üëê Set Up Lab","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/mongodb-atlas/setup-lab","content":"üëê Set Up Lab To follow along, you'll need: A MongoDB Atlas account.Test data. In this case, this is book, author, and review data for a library management system. üëê To get this data set, open the intro lab and follow it (do only sections MongoDB Atlas and Importing Data, this should take you 10-15 mins) to get your database ready. Return here when finished!","keywords":"","version":"Next"},{"title":"üëê Empty Aggregation Pipeline","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/empty-aggregation","content":"","keywords":"","version":"Next"},{"title":"An empty aggregation‚Äã","type":1,"pageTitle":"üëê Empty Aggregation Pipeline","url":"/aggregation-pipeline-lab/docs/simple-queries/empty-aggregation#an-empty-aggregation","content":" This code is the equivalent of a SELECT * FROM AUTHORS. It returns a cursor with all documents in the authors collection:  Atlas UIMongoDB Shell Make sure Collections &gt; authors is selected.Open the Aggregation tab.Select Text.Notice the empty array in the editor denoting an empty aggregation pipeline: [] You're getting all documents in authors (although the Atlas UI is only showing a 10 documents sample) ","version":"Next","tagName":"h2"},{"title":"üëê Combining stages","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/combining-them-all","content":"üëê Combining stages Up until now, we've just been using one stage in the pipeline. But the power of the aggregation pipeline is that we can use many stages, and the output of one will be the input of the next. Think of it as UNIX pipes or using functional programming with map, filter, reduce, flatmap, etc. Get 5 books from 2001 with more than 50 pages. Show only the title and authors. Atlas UIMongoDB Shell [ { $match: { year: 2001, pages: {$gt: 50 } } }, { $project: { _id: 0, title: 1, authors: 1 } }, { $limit: 5 }, ] We're using here the greater than $gt operator. You have $gt, $gte, $lt, etc. üëê Get 15 books from 1985 with less than 150 pages. Show only the title, year, totalInventory, and available books. If you don't remember which fields we have, you can refer to the sample document. Answer Atlas UIMongoDB Shell [ { $match: { year: 1985, pages: { $lt: 150 } } }, { $project: { _id: 0, title: 1, year: 1, totalInventory: 1, available: 1 } }, { $limit: 15 }, ] ","keywords":"","version":"Next"},{"title":"üëê Removing Fields from Results","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/modifying-results/unset-fields","content":"","keywords":"","version":"Next"},{"title":"$unset‚Äã","type":1,"pageTitle":"üëê Removing Fields from Results","url":"/aggregation-pipeline-lab/docs/modifying-results/unset-fields#unset","content":" We can remove fields from the results, either using $project or more fine-grained, using $unset. If we don't want the attributes we can do:  Atlas UIMongoDB Shell [ {$unset: &quot;attributes&quot;} ]   üëê Remove from results the fields totalInventory and available.  Answer Atlas UIMongoDB Shell Several ways to do this, other than using $project: [ {$unset: &quot;totalInventory&quot;}, {$unset: &quot;available&quot;}, ] // or [ {$unset: [&quot;totalInventory&quot;, &quot;available&quot;] }, ] info $set is an alias for $addFields that you'll find on many older posts and documentation. ","version":"Next","tagName":"h2"},{"title":"üëê $match","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/match","content":"","keywords":"","version":"Next"},{"title":"Expressions‚Äã","type":1,"pageTitle":"üëê $match","url":"/aggregation-pipeline-lab/docs/simple-queries/match#expressions","content":" The &lt;expression&gt; portion of the $match stage can be any valid MongoDB expression. This includes:  Comparison operators: eq, neq, gte, lte, gt, lt, in, nin, exists.Regular expressions: regex.Logical operators: and, or, not.Subdocuments and arrays: { field: &lt;value&gt; }, [ &lt;item&gt;, &lt;item&gt;, ... ].  ","version":"Next","tagName":"h2"},{"title":"Matching book documents‚Äã","type":1,"pageTitle":"üëê $match","url":"/aggregation-pipeline-lab/docs/simple-queries/match#matching-book-documents","content":" Atlas UIMongoDB Shell First, make sure you select the books collection in the Atlas UI. Then, navigate to the Aggregation tab and click &lt;/&gt; TEXT. Say we want all the books from the year 2010. We can add a $match stage to filter the documents from the books collection: [ { $match: { year: 2010 } } ]   üëê Return all the books that have exactly 100 pages.  Answer Atlas UIMongoDB Shell [ { $match: { pages: 100 } } ]   ","version":"Next","tagName":"h2"},{"title":"AND‚Äã","type":1,"pageTitle":"üëê $match","url":"/aggregation-pipeline-lab/docs/simple-queries/match#and","content":" If we need to add more conditions using AND, we use the $and operator.  If we want all the books with 100 pages and with exactly totalInventory 1, we can use the $and operator. It takes an array of documents with all the conditions that should be true for the AND to succeed:  Atlas UIMongoDB Shell [ { $match: { $and: [ { pages: 100 }, { totalInventory: 1 } ] } } ]   The pseudo-code for this would be something like:  IF pages == 100 AND totalInventory == 1 { return matching docs }   üëê Return all the books from 2015 that have exactly 100 pages.  Answer Atlas UIMongoDB Shell [ { $match: { $and: [ { pages: 100 }, { year: 2015 } ] } } ]   üëê How many are there? We haven't yet seen the $count stage, but try to adding a second stage to your pipeline with { $count: &quot;books_count&quot; }  Answer Atlas UIMongoDB Shell [ { $match: { $and: [ { pages: 100 }, { year: 2015 } ] } }, { $count: &quot;books_count&quot; } ]   ","version":"Next","tagName":"h2"},{"title":"Shorthand AND‚Äã","type":1,"pageTitle":"üëê $match","url":"/aggregation-pipeline-lab/docs/simple-queries/match#shorthand-and","content":" We can do an implicit AND just passing a document with all the conditions (instead of an array of documents):  Atlas UIMongoDB Shell [ { $match: { pages: 100, totalInventory: 2 } } ]   üëê Return all the books from 2015 that have exactly 100 pages, using the shorthand $and notation:  Answer Atlas UIMongoDB Shell [ { $match: {pages: 100, year: 2015} } ]  ","version":"Next","tagName":"h3"},{"title":"ü¶∏‚Äç‚ôÇÔ∏è Repeating Stages","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/repeating-stages","content":"ü¶∏‚Äç‚ôÇÔ∏è Repeating Stages info Extra activity! Do it if you have extra time or are following along at home. It won't be covered during the hands-on lab. From the aggregation pipelines manual: All stages except the $out, $merge, $geoNear, $changeStream, and $changeStreamSplitLargeEvent stages can appear multiple times in a pipeline. So we can repeat most stages, and do something like this to get all books from 1985 with more than 100 pages (although it may or may not make sense): Atlas UIMongoDB Shell [ { $match: { pages: {$gte: 100} } }, { $match: { year: 1985 } } ] üíª Add several $limit stages at the end of the above aggregation, limiting to 1 book, and see what happens. Answer Atlas UIMongoDB Shell [ {$match: {pages: {$gte: 100}}}, {$match: {year: 2011}}, {$limit: 1}, {$limit: 1}, ] ","keywords":"","version":"Next"},{"title":"üëê $limit","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/limiting-results","content":"üëê $limit If we return too many documents but we're interested in only a few, we can limit the number of documents returned using $limit. Atlas UIMongoDB Shell [ { $limit: 1 } ] This returns just one document. üëê Return just 7 books. Answer Atlas UIMongoDB Shell [ { $limit: 7 } ] ","keywords":"","version":"Next"},{"title":"üëê Using the Library Database","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/using-library-database","content":"","keywords":"","version":"Next"},{"title":"Select the library database‚Äã","type":1,"pageTitle":"üëê Using the Library Database","url":"/aggregation-pipeline-lab/docs/simple-queries/using-library-database#select-the-library-database","content":" üíª We'll use the library database for all of the hands-on exercises in this lab. If you haven't already, import the library data into your database cluster.  Atlas UIMongoDB Shell Select the correct database in the aggregation pipeline builder. ","version":"Next","tagName":"h2"},{"title":"üéØ Summary","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/summary","content":"üéØ Summary Congratulations! Following this tutorial, you have successfully: Found documents for a given set of criteria using the aggregation pipeline framework.Performed grouping, transformations, and aggregations using aggregation pipelines.Exported data from the pipeline. Visit the MongoDB Developer Center for more useful information and tutorials.","keywords":"","version":"Next"},{"title":"ü¶∏‚Äç‚ôÇÔ∏è Writing Long Pipelines","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/writing-long-pipelines","content":"ü¶∏‚Äç‚ôÇÔ∏è Writing Long Pipelines info Extra activity! Do it if you have extra time or are following along at home. It won't be covered during the hands-on lab. Aggregation pipelines can get very long, depending on how many stages we need to run. Writing a pipeline is writing code, as you will write it using one of the many MongoDB drivers in your own language. Here we're presenting the examples using JavaScript suitable for the MongoDB shell mongosh, but if you are writing a microservice in Rust, you'll definitely write your pipelines in Rust. danger The following syntax doesn't work in the Atlas UI aggregations editor. The editor doesn't support declaring variables. You can try this using the built-in MongoDB Shell in MongoDB Compass. This is why we should rewrite our last pipeline like this: Get 15 books from 1985 with less than 150 pages. Show only the title, year, totalInventory, and available books (sample doc here). MongoDB Shell db.books.aggregate([ { $match: {year: 1985, pages: { $lt: 150 } } }, { $project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1} }, { $limit: 15 } ]) Will be changed into: let lessThan150 = { $lt: 150 }; let booksFrom1985With150pages = {$match: {year: 1985, pages: lessThan150 }}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}; let getJust15books = {$limit: 15}; db.books.aggregate([ booksFrom1985With150pages, showOnlyTheseFields, getJust15books, ]); Easier to read and understand, right? üëê Try to run the above pipeline and compare your results. They should be the same as before. tip Write your aggregation pipelines like you'll compose functions in your programming language. Aggregations are code that runs on the server. In the client, you just express what you want to be done, not how to do it. tip As this is code, we can even add comments (starting with //) to our pipelines. Or write functions that take parameters and return a stage. Or unit test our stages. üëê We can also use $gte to get the books with 150 pages or more. Check $gte syntax in the docucumentation and write an aggregation pipeline to return 15 books from 1985 with more than 150 pages. Show only the title, year, totalInventory, and available books (sample doc here). Answer let moreThan150pages = {pages: {$gte: 150}} let booksFrom1985WithMoreThan150pages = {$match: {$and: [{year: 1985}, moreThan150pages]}}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}; let getJust15books = {$limit: 15}; db.books.aggregate([ booksFrom1985WithMoreThan150pages, showOnlyTheseFields, getJust15books, ]); ","keywords":"","version":"Next"},{"title":"üëê $project","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/project","content":"","keywords":"","version":"Next"},{"title":"Including fields in a projection‚Äã","type":1,"pageTitle":"üëê $project","url":"/aggregation-pipeline-lab/docs/simple-queries/project#including-fields-in-a-projection","content":" A document from the books collection looks like:  { _id: '0395623650', title: 'Platero y yo / Platero and I (Spanish-English Bilingual Edition) (English and Spanish Edition)', authors: [ { _id: '64cc2db4830ba29148db5180', name: 'Juan Ram√≥n Jim√©nez' } ], pages: 64, year: 1994, synopsis: 'Selections from a classic of world literature present a picture of life in the town of Moguer, in Andalusia, Spain.\\n' + '\\n' + '\\n' + ' Presents a picture of life in the town of Moguer, in Andalusia, Spain, as seen through the eyes of a wandering poet and his faithful donkey.\\n', cover: 'https://images.isbndb.com/covers/36/57/9780395623657.jpg', attributes: [ { key: 'edition', value: 'F First Edition Thus' }, { key: 'dimensions', value: 'Height: 10.499979 Inches, Length: 6.999986 Inches, Weight: 2.0502990366 Pounds, Width: 0.12499975 Inches' }, { key: 'isbn13', value: '9780395623657' }, { key: 'msrp', value: 1.99 }, { key: 'isbn', value: '0395623650' }, { key: 'isbn10', value: '0395623650' } ], totalInventory: 1, available: 1, binding: 'Hardcover', language: 'en', longTitle: 'Platero y yo / Platero and I (Spanish-English Bilingual Edition) (English and Spanish Edition)', publisher: 'Clarion Books' }   If we're interested in the titles, we can use $project to select just the fields we're interested in. As an example, to get just the book's title and year, we'll write:  Atlas UIMongoDB Shell [ { $project: { title: 1, year: 1 } } ]   1 means &quot;show that field.&quot;. Once you started an inclusion projection you can't exclude other fields (you just keep adding the fields you want to see)0 means &quot;hide that field.&quot;. Once you started an exclusion projection you can't include other fields (you just keep adding the fields you don't want to see)The primary key _id field is shown by default.  So we can exclude fields and show all fields except attributes using:  Atlas UIMongoDB Shell [ { $project: { attributes: 0 } } ]   üëê Show only title and cover.  Answer Atlas UIMongoDB Shell [ { $project: { title: 1, cover: 1 } } ]   ","version":"Next","tagName":"h2"},{"title":"Excluding fields‚Äã","type":1,"pageTitle":"üëê $project","url":"/aggregation-pipeline-lab/docs/simple-queries/project#excluding-fields","content":" üëê Exclude the cover, attributes, and _id fields from the result.  Answer Atlas UIMongoDB Shell [ { $project: {_id: 0, attributes: 0, cover: 0} } ]   ","version":"Next","tagName":"h2"},{"title":"Including and excluding fields‚Äã","type":1,"pageTitle":"üëê $project","url":"/aggregation-pipeline-lab/docs/simple-queries/project#including-and-excluding-fields","content":" danger You can't include and exclude fields in the same projection. If you start including, you must keep including, and vice versa.  For instance, this will fail:  db.books.aggregate([{$project: {title: 1, attributes: 0}}]) MongoServerError: Invalid $project :: caused by :: Cannot do exclusion on field attributes in inclusion projection   info The only exception to this rule is the _id field, which we can exclude in an inclusion projection.  db.books.aggregate([{$project: {title: 1, _id: 0}}])  ","version":"Next","tagName":"h2"},{"title":"ü¶∏ Size of an array","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/using-arrays/array-sizes","content":"ü¶∏ Size of an array What if we want to know how many aliases an author has? To do that, we can use $size, adding the array field that we're interested in: Atlas UIMongoDB Shell [ { $project: { name: 1, bookCount: {$size: &quot;$books&quot;} } }, ] üëê Who wrote the most books? (We can sort using { $sort: {&quot;bookCount&quot;: -1}}.) Answer Atlas UIMongoDB Shell [ { $project: { name: 1, bookCount: {$size: &quot;$books&quot;} } }, { $sort: {&quot;bookCount&quot;: -1} }, { $limit: 1 } ] üëê Find books with exactly three genres (We can $match using { {&quot;bookCount&quot;: -1}}.) Answer Atlas UIMongoDB Shell [ { $match: { genres: {$size: 3 } } }, {$project: { title: 1, genres: 1 }} ] ","keywords":"","version":"Next"},{"title":"üëê Simple arrays","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/using-arrays/simple-match-array","content":"","keywords":"","version":"Next"},{"title":"üëê Get all the Science Fiction Books‚Äã","type":1,"pageTitle":"üëê Simple arrays","url":"/aggregation-pipeline-lab/docs/using-arrays/simple-match-array#-get-all-the-science-fiction-books","content":" Can I get all books for the genre Science Fiction?. Turns out it's quite simple:  Atlas UIMongoDB Shell [ { $match: { genres: 'Science Fiction' } } ]   Remember that will include any book that has any other genre as long as it has Science Fiction in genres.  ","version":"Next","tagName":"h2"},{"title":"üëê Find all the books that belong at least to both genres \"Fiction\" and \"Science Fiction\"‚Äã","type":1,"pageTitle":"üëê Simple arrays","url":"/aggregation-pipeline-lab/docs/using-arrays/simple-match-array#-find-all-the-books-that-belong-at-least-to-both-genres-fiction-and-science-fiction","content":" If you want to search for all books that have &quot;Fiction&quot; and &quot;Science Fiction&quot;, in any order (and possibly other genres) use:  Atlas UIMongoDB Shell [ {$match: { genres: {$all: ['Science Fiction', 'Fiction'] } } }, {$project: { title: 1, genres: 1 }} ]   ","version":"Next","tagName":"h2"},{"title":"üëê Find books with either genre‚Äã","type":1,"pageTitle":"üëê Simple arrays","url":"/aggregation-pipeline-lab/docs/using-arrays/simple-match-array#-find-books-with-either-genre","content":" Atlas UIMongoDB Shell [{ $match: { genres: { $in: ['Science Fiction', 'Fiction'] } } } ]   ","version":"Next","tagName":"h2"},{"title":"üëê Find all the books that belong only to the genres \"Fiction\" and \"Science Fiction\"‚Äã","type":1,"pageTitle":"üëê Simple arrays","url":"/aggregation-pipeline-lab/docs/using-arrays/simple-match-array#-find-all-the-books-that-belong-only-to-the-genres-fiction-and-science-fiction","content":" In this case, we want books that have both &quot;Fiction&quot; and &quot;Science Fiction&quot; in the genres array and nothing else. So we're looking for documents that contain a genres array exactly as ['Fiction', 'Science Fiction']. We're not looking for the individual genres that could be inside the array, instead we are comparing the whole array on each document.  Atlas UIMongoDB Shell [ {$match: { genres: ['Fiction', 'Science Fiction'] } }, {$project: { title: 1, genres: 1 }} ]   Here we're comparing the whole array. Element order is important. With this comparison you'll get nothing in return:  Atlas UIMongoDB Shell [ {$match: { genres: ['Science Fiction', 'Fiction'] } }, {$project: { title: 1, genres: 1 }} ]  ","version":"Next","tagName":"h2"},{"title":"üìò SQL vs Aggregations","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation","content":"","keywords":"","version":"Next"},{"title":"SQL‚Äã","type":1,"pageTitle":"üìò SQL vs Aggregations","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation#sql","content":" A SQL query statement usually starts with a SELECT where we put a list of the fields we need, then a FROM clause to state the table/s (or in this case, the subquery) that will return the rows. We can filter out using WHERE and group data using GROUP.  We read this from the inside. If there's too much nesting, it's not easy to follow.  ","version":"Next","tagName":"h2"},{"title":"Get authors‚Äô bios with books that have an average 5-star rating‚Äã","type":1,"pageTitle":"üìò SQL vs Aggregations","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation#get-authors-bios-with-books-that-have-an-average-5-star-rating","content":" SELECT authors.name, authors.bio FROM library.authors authors JOIN library.author_book author_book_join ON authors.id = author_book_join.author_id JOIN ( SELECT books.id FROM library.books books JOIN library.reviews reviews ON books.id = reviews.book_id GROUP BY books.id HAVING AVG(reviews.rating) = 5 ) five_star_books ON author_book_join.book_id = five_star_books.id;   ","version":"Next","tagName":"h3"},{"title":"Get annual, average and max spending from customers in all cities‚Äã","type":1,"pageTitle":"üìò SQL vs Aggregations","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation#get-annual-average-and-max-spending-from-customers-in-all-cities","content":" SELECT city, SUM(annual_spend) Total_Spend, AVG(annual_spend) Average_Spend, MAX(annual_spend) Max_Spend, COUNT(annual_spend) customers FROM ( SELECT t1.city, customer.annual_spend FROM customer LEFT JOIN ( SELECT address.address_id, city.city, address.customer_id, address.location FROM address LEFT JOIN city ON address.city_id = city.city_id ) AS t1 ON (customer.customer_id = t1.customer_id AND t1.location = &quot;home&quot;) ) AS t2 GROUP BY city;   ","version":"Next","tagName":"h3"},{"title":"Equivalent MongoDB aggregation pipeline‚Äã","type":1,"pageTitle":"üìò SQL vs Aggregations","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation#equivalent-mongodb-aggregation-pipeline","content":" ","version":"Next","tagName":"h2"},{"title":"Get authors‚Äô bios with books that have an average 5-star rating‚Äã","type":1,"pageTitle":"üìò SQL vs Aggregations","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation#get-authors-bios-with-books-that-have-an-average-5-star-rating-1","content":" We o through 4 stages:  group all the reviews for every book, calculating the average rating.filter out all average ratings other than 5.now we have reviews with 5 stars, but we also want the author bio, so we join with author to get the bio.we add a new field called bio with just the author's bio.  db.reviews.aggregate([ { $group: { _id: &quot;$bookId&quot;, averageRating: { $avg: &quot;$rating&quot;, }, }, }, { $match: { averageRating: 5 } }, { $lookup: { from: &quot;authors&quot;, localField: &quot;_id&quot;, foreignField: &quot;books&quot;, as: &quot;author&quot;, }, }, {$addFields: { bio: &quot;$author.bio&quot; }}, ])   ","version":"Next","tagName":"h3"},{"title":"Get annual, average and max spending from customers in all cities‚Äã","type":1,"pageTitle":"üìò SQL vs Aggregations","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation#get-annual-average-and-max-spending-from-customers-in-all-cities-1","content":" Here we pass three stages: one to return one document per element in the address array, and then we filter out to get only the documents that have a home address location. Finally, we do the grouping. As we'll see, this can be split and tested separately and resembles our code.  db.customers.aggregate([ { $unwind: &quot;$address&quot;, }, { $match: {&quot;address.location&quot;: &quot;home&quot;} }, { $group: { _id: &quot;$address.city&quot;, totalSpend: {$sum: &quot;$annualSpend&quot;}, averageSpend: {$avg: &quot;$annualSpend&quot;}, maximumSpend: {$max: &quot;$annualSpend&quot;}, customers: {$sum: 1} } } ])   info See also SQL to Aggregation Mapping Chart ","version":"Next","tagName":"h3"},{"title":"üìò Structure of an Aggregation Pipeline","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/structure-aggregation","content":"","keywords":"","version":"Next"},{"title":"Example‚Äã","type":1,"pageTitle":"üìò Structure of an Aggregation Pipeline","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/structure-aggregation#example","content":" // Inside the current database, in the collection named reviews db.reviews.aggregate([ { // group all reviews for the same book $group: { _id: &quot;$bookId&quot;, averageRating: { $avg: &quot;$rating&quot;, }, }, }, // filter out all reviews that have an average other than 5 { $match: { averageRating: 5 } }, // JOIN with author collection to get all the author info { $lookup: { from: &quot;authors&quot;, localField: &quot;_id&quot;, foreignField: &quot;books&quot;, as: &quot;author&quot;, }, }, // add a field called bio {$addFields: { bio: &quot;$author.bio&quot; }}, ])  ","version":"Next","tagName":"h2"},{"title":"üëê Searching inside Objects in arrays","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/using-arrays/search-inside-objects-in-arrays","content":"","keywords":"","version":"Next"},{"title":"Matching object fields, the simplest way‚Äã","type":1,"pageTitle":"üëê Searching inside Objects in arrays","url":"/aggregation-pipeline-lab/docs/using-arrays/search-inside-objects-in-arrays#matching-object-fields-the-simplest-way","content":" How do we search for all the books that have an msrp of 9.99? We want books that, inside attributes, have an object with key msrp and value 9.99?  Atlas UIMongoDB Shell [ { $match: {&quot;attributes.key&quot;: &quot;msrp&quot;, &quot;attributes.value&quot;: 9.99} }, { $project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1, &quot;attributes&quot;: 1} } ]   Above example is using the shorthand $and operator, that we can also explicitly write:  Atlas UIMongoDB Shell [ { $match: { $and: [{&quot;attributes.key&quot;: &quot;msrp&quot;, &quot;attributes.value&quot;: 9.99}] } }, { $project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1, &quot;attributes&quot;: 1} } ]   Find all the books with an MSPR of 9.99 and that have been reprinted (hint: edition is Reprint)  Answer Atlas UIMongoDB Shell [ { $match: {$and: [ {&quot;attributes.key&quot;: &quot;msrp&quot;, &quot;attributes.value&quot;: 9.99}, {&quot;attributes.key&quot;: &quot;edition&quot;, &quot;attributes.value&quot;: &quot;Reprint&quot;}] } }, { $project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1, &quot;attributes&quot;: 1} } ]   This is okay, but We get a list of documents with a whole bunch of attributes which looks like the following:  { &quot;_id&quot;: &quot;0002005018&quot;, &quot;title&quot;: &quot;Clara Callan: A novel&quot;, &quot;attributes&quot;: [ { &quot;key&quot;: &quot;edition&quot;, &quot;value&quot;: &quot;1st&quot; }, { &quot;key&quot;: &quot;dimensions&quot;, &quot;value&quot;: &quot;Height: 11.11 Inches, Length: 6.11 Inches, Weight: 1 Pounds, Width: 1.11 Inches&quot; }, { &quot;key&quot;: &quot;isbn13&quot;, &quot;value&quot;: &quot;9780002005012&quot; }, { &quot;key&quot;: &quot;msrp&quot;, &quot;value&quot;: &quot;0.00&quot; }, { &quot;key&quot;: &quot;isbn&quot;, &quot;value&quot;: &quot;0002005018&quot; }, { &quot;key&quot;: &quot;isbn10&quot;, &quot;value&quot;: &quot;0002005018&quot; } ] }   What if we are only interested in the MSRP?  There is more than one way to filter the unncessary keys and values:  ","version":"Next","tagName":"h2"},{"title":"1. Using $unwind aggregation stage‚Äã","type":1,"pageTitle":"üëê Searching inside Objects in arrays","url":"/aggregation-pipeline-lab/docs/using-arrays/search-inside-objects-in-arrays#1-using-unwind-aggregation-stage","content":" See the following pipeline:  Atlas UIMongoDB Shell [ { $unwind : &quot;$attributes&quot; }, { $match: {&quot;attributes.key&quot;: &quot;msrp&quot;, &quot;attributes.value&quot;: 9.99} }, { $project: {title: 1, attributes: 1} } ]   Here we're getting a copy of each book for each object inside the $attributes array. This &quot;flattens&quot; the array and returns many copies of the same documents, one for each different attribute that we have.  üëê To better understand $unwind, run this aggregation.  Atlas UIMongoDB Shell You need to select the books collection. [ { $match: {_id: &quot;0395623650&quot;} }, { $unwind : &quot;$attributes&quot; }, ]   You should get one document per attribute of the original book. All fields in these returned documents should be the same, except the ones in attributes.  ","version":"Next","tagName":"h3"},{"title":"ü¶∏ 2. Using $arrayToObject operator‚Äã","type":1,"pageTitle":"üëê Searching inside Objects in arrays","url":"/aggregation-pipeline-lab/docs/using-arrays/search-inside-objects-in-arrays#-2-using-arraytoobject-operator","content":" We can also flatten the attributes array into an object using the $arrayToObject operator and then use a $project stage to filter unwanted fields. Note that $arrayToObject is not an aggregation stage.  Atlas UIMongoDB Shell You need to select the books collection. [ { $match: { 'attributes.key': 'msrp', 'attributes.value': 9.99 } }, { $addFields: { attributes: { $arrayToObject: { $map: { input: '$attributes', as: 'attr', in: { k: '$$attr.key', v: '$$attr.value' } } } } } }, { $project: { title: 1, 'attributes.msrp': 1 } } ]   ü¶∏ Run the above aggregation to observe the difference in output as compared to using $unwind. ","version":"Next","tagName":"h3"},{"title":"üìò What is an Aggregation Pipeline?","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/what-is-aggregation","content":"üìò What is an Aggregation Pipeline? An aggregation pipeline is similar to unix commands connected using pipes. We can construct modular, composable processing pipelines. An aggregation pipeline consists of one or more stages that process documents: Each stage performs an operation on the input documents. For example, a stage can filter documents, group documents, and calculate values. The documents that are the output of a stage are passed as the input to the next stage. An aggregation pipeline can return results for groups of documents. For example, return the total, average, maximum, and minimum values, etc.","keywords":"","version":"Next"},{"title":"üëê Types of arrays","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/using-arrays/types-of-arrays","content":"","keywords":"","version":"Next"},{"title":"Array of strings example‚Äã","type":1,"pageTitle":"üëê Types of arrays","url":"/aggregation-pipeline-lab/docs/using-arrays/types-of-arrays#array-of-strings-example","content":"  &quot;genres&quot;: [ &quot;Women Teachers&quot;, &quot;Young Women&quot;, &quot;Actresses&quot;, &quot;Sisters&quot; ],   ","version":"Next","tagName":"h3"},{"title":"Array of objects example‚Äã","type":1,"pageTitle":"üëê Types of arrays","url":"/aggregation-pipeline-lab/docs/using-arrays/types-of-arrays#array-of-objects-example","content":"  &quot;attributes&quot;: [ { &quot;key&quot;: &quot;edition&quot;, &quot;value&quot;: &quot;1st&quot; }, { &quot;key&quot;: &quot;dimensions&quot;, &quot;value&quot;: &quot;Height: 11.11 Inches, Length: 6.11 Inches, Weight: 1 Pounds, Width: 1.11 Inches&quot; }, { &quot;key&quot;: &quot;isbn13&quot;, &quot;value&quot;: &quot;9780002005012&quot; }, { &quot;key&quot;: &quot;msrp&quot;, &quot;value&quot;: &quot;0.00&quot; }, { &quot;key&quot;: &quot;isbn&quot;, &quot;value&quot;: &quot;0002005018&quot; }, { &quot;key&quot;: &quot;isbn10&quot;, &quot;value&quot;: &quot;0002005018&quot; } ],  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}