{"searchDocs":[{"title":"🦸 保存到集合","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/exporting-data/saving-to-collection","content":"🦸 保存到集合 你可以将聚合管道的结果导出到不同的数据库/集合。为此，只需在管道的最后添加一个聚合阶段： { $out: { db: &quot;&lt;output-db&gt;&quot;, coll: &quot;&lt;output-collection&gt;&quot; } } 你可以省略db属性，这种情况下新集合将创建在当前数据库中。 { $out: &quot;&lt;output-collection&gt;&quot; } 👐 创建一本正好有100页的书的副本，并输出为一个名为OneHundredPagesBooks的新集合。 答案 let oneHundredPagesBooks = {$match: {pages: 100}}; let saveToNewCollection = {$out: &quot;OneHundredPagesBooks&quot;} db.books.aggregate([ oneHundredPagesBooks, saveToNewCollection ]); 运行此代码后，我们应该看到一个新集合： show collections ","keywords":"","version":"当前版本"},{"title":"👐 $count","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/counting-sorting/counting-documents","content":"","keywords":"","version":"当前版本"},{"title":"阶段的顺序很重要​","type":1,"pageTitle":"👐 $count","url":"/aggregation-pipeline-lab/zh/docs/counting-sorting/counting-documents#阶段的顺序很重要","content":" 如果我们在$match阶段之后进行计数，我们传递给下一步骤的文档只包含totalBooks字段。因此，$project阶段将返回一个空文档。  let moreThan150pages = {pages: {$gte: 150}} let booksFrom1985WithMoreThan150pages = {$match: {$and: [{year: 1985}, moreThan150pages]}}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}; let getJust15books = {$limit: 15}; let count = {$count: &quot;totalBooks&quot;} db.books.aggregate([ booksFrom1985WithMoreThan150pages, count, showOnlyTheseFields, getJust15books, ]);  ","version":"当前版本","tagName":"h2"},{"title":"介绍","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/intro","content":"介绍 实验目标\t了解聚合管道，编写聚合管道你将学到\t什么是聚合管道 它们与简单的 MongoDB 查询或 SQL 有什么不同 如何使用简单的聚合管道获取数据、过滤数据、显示所需的字段 如何编写更高级的管道，查询数组、计数和排序结果 如何使用 $lookup 进行跨集合 JOIN 如何对数据进行分组 如何导出数据 如何使用流行的编程语言编写聚合（待定） 完成时间\t90 分钟 在导航栏和某些页面中，你会注意到一些图标。它们的含义如下： 图标\t含义📘\t讲义材料 - 如果您正在跟随导师主导的课程，他们可能已经覆盖了这些材料。 👐\t动手内容 - 准备好进行一些实际操作。您应该按照这些步骤进行。 💬\t话题讨论 - 在实验期间参与讨论的项目。 🦸\t高级内容 - 这些内容在实验期间未覆盖，但如果您有兴趣了解更多，可以查看。","keywords":"","version":"当前版本"},{"title":"📘 讲座材料","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/lecture-material","content":"","keywords":"","version":"当前版本"},{"title":"聚合管道备忘单​","type":1,"pageTitle":"📘 讲座材料","url":"/aggregation-pipeline-lab/zh/docs/lecture-material#聚合管道备忘单","content":"   无法显示 PDF 文件。请点击 下载。 ","version":"当前版本","tagName":"h2"},{"title":"👐 $group","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/grouping/group","content":"👐 $group 我们可以计算每年所有书籍的总页数： db.books.aggregate([ {$group:{ _id: &quot;$year&quot;, totalPages: {$sum: &quot;$pages&quot;} }} ]) 在这里，我们按书籍的year进行分组（分组并作为新的_id），然后创建一个名为totalPages的新字段，这个字段是所有页数的总和。 👐 你能获取按年份升序排序的结果吗？ 答案 db.books.aggregate([ {$group:{ _id: &quot;$year&quot;, totalPages: {$sum: &quot;$pages&quot;} }}, {$sort: {_id: 1}} ]) 👐 你能获取每年的平均页数吗（提示：使用$avg）？ 答案 db.books.aggregate([ {$group:{ _id: &quot;$year&quot;, totalPages: {$avg: &quot;$pages&quot;} }}, {$sort: {_id: 1}} ]) 👐 哪一年印刷了最多的页数？ 答案 db.books.aggregate([ {$group:{ _id: &quot;$year&quot;, totalPages: {$sum: &quot;$pages&quot;} }}, {$sort: {totalPages: -1}}, {$limit: 1} ]) ","keywords":"","version":"当前版本"},{"title":"👐 向结果添加新字段","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/modifying-results/adding-fields","content":"","keywords":"","version":"当前版本"},{"title":"$addFields​","type":1,"pageTitle":"👐 向结果添加新字段","url":"/aggregation-pipeline-lab/zh/docs/modifying-results/adding-fields#addfields","content":" 我们想估计一本书的阅读时间。但我们没有将该字段存储在数据中。我们可以使用$addFields来实现。如果该字段存在，它将被更新，如果不存在，则添加。  db.books.aggregate([ {$project: { title: 1, pages: 1, } }, {$addFields: {readingTimeHours: {$divide: [{$multiply: [&quot;$pages&quot;, 2]}, 60]}}}, ])   👐 为所有文档添加一个包含文本PLACEHOLDER的新字段notes。  答案 db.books.aggregate([ {$project: { title: 1, pages: 1, } }, {$addFields: {notes: &quot;PLACEHOLDER&quot;}} ])  ","version":"当前版本","tagName":"h2"},{"title":"👐 Lookup 又名 Left Outer Join（外连接）","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/lookups/lookups","content":"","keywords":"","version":"当前版本"},{"title":"从之前的阶段进行查找​","type":1,"pageTitle":"👐 Lookup 又名 Left Outer Join（外连接）","url":"/aggregation-pipeline-lab/zh/docs/lookups/lookups#从之前的阶段进行查找","content":" 我们可以对另一个管道的结果进行$lookup，而不仅仅是与一个集合连接。例如，我们想在连接之前从书籍中删除一些噪音，所以我们使用$project排除几个数组。  db.authors.aggregate([ {$lookup: { from: &quot;books&quot;, localField: &quot;books&quot;, foreignField: &quot;_id&quot;, pipeline: [ {$project: {title: 1, synopsis: 1}} ], as: &quot;booksWritten&quot; } } ])   更好的做法是我们可以提取该管道并进行测试/调整。  let justShowTitleSynopsis = [ {$project: {title: 1, synopsis: 1}}, ] db.authors.aggregate([ {$lookup: { from: &quot;books&quot;, localField: &quot;books&quot;, foreignField: &quot;_id&quot;, pipeline: justShowTitleSynopsis, as: &quot;booksWritten&quot; } } ])  ","version":"当前版本","tagName":"h2"},{"title":"🦸‍♂️ 高级 lookup","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/lookups/advanced-lookups","content":"🦸‍♂️ 高级 lookup 信息 额外活动：如果您有额外的时间或在家跟着做，可以尝试，导师不会在动手实验中进行讲解 我们收到这样的需求：写一个$lookup，以获取每个书籍文档中作者的信息，包括name和bio。为了完成这个任务，我们需要回顾几件事情： 每本书可以有多个作者。这种多对多的关系（因为一个作者也可以写多本书）是通过两个不同的数组来建模的：authors集合中的一个books数组和books集合中的一个authors数组。所以我们需要为每本有多个作者的书籍获取一个单独的文档。如果一本书有三个作者，我们将使用$unwind来获取三个文档，这些文档的数据相同，除了作者字段的内容不同。 你可以使用这个聚合管道来尝试： db.books.aggregate([ // 因为一本书可以有多个作者，我们为每个书籍的作者获取一个文档 {$unwind: &quot;$authors&quot;}, // 删除一些干扰字段 {$project: {attributes: 0, reviews: 0}} ]) 现在，我们需要获取作者的信息。为此，我们将使用$lookup，将authors集合中的_id与我们在每本书的authors数组中的_id进行链接。但正如我们在这里看到的，这些类型不同：我们数组中的那些是字符串，而authors集合中的_id是ObjectId。 authors: { _id: '64cc2db4830ba29148da64a2', name: 'Timothy Findley' }, 所以我们需要将String转换为ObjectId。我们可以使用$toObjectId来做到这一点。这将添加一个新字段authorId，将其转换为ObjectId： db.books.aggregate([ // 因为一本书可以有多个作者，我们为每个书籍的作者获取一个文档 {$unwind: &quot;$authors&quot;}, // 将其转换为ObjectId {&quot;$set&quot;:{&quot;authorId&quot;:{&quot;$toObjectId&quot;:&quot;$authors._id&quot;}}}, // 删除一些干扰字段 {$project: {attributes: 0, reviews: 0}} ]) 现在我们准备进行$lookup：我们希望获取所有authors中_id与我们刚刚创建的authorId相同的文档。我们使用一个pipeline来仅获取authors的name和bio。 db.books.aggregate([ // 因为一本书可以有多个作者，我们为每个书籍的作者获取一个文档 {$unwind: &quot;$authors&quot;}, // 将其转换为ObjectId {&quot;$set&quot;:{&quot;authorId&quot;:{&quot;$toObjectId&quot;:&quot;$authors._id&quot;}}}, {$lookup: { from: &quot;authors&quot;, localField: &quot;authorId&quot;, foreignField: &quot;_id&quot;, pipeline: [ {$project: {name: 1, bio: 1}}, ], as: &quot;bookAuthorDetails&quot; } }, // 删除一些干扰字段 {$project: {attributes: 0, reviews: 0}} ]) ","keywords":"","version":"当前版本"},{"title":"👐 设置实验","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/mongodb-atlas/setup-lab","content":"👐 设置实验 要跟上进度，您需要： 一个 MongoDB Atlas 账户一个 MongoDB 集群测试数据。在本例中，这是用于图书馆管理系统的书籍、作者和评论数据。 👐 要获取这两者，请打开 入门实验 并按照步骤操作（只需 10-15 分钟）以准备好您的数据库。完成后返回这里！","keywords":"","version":"当前版本"},{"title":"🦸 缺失数据","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/modifying-results/missing-data","content":"🦸 缺失数据 有时我们会缺少我们正在寻找的字段（它不存在，因为集合中的文档可以是多态的，所以该字段为null）。对于这些情况，我们可以使用$ifNull检查某些内容是否存在，并在这种情况下添加一个默认值。 let getAuthorsWithBooks = { $project: { name: 1, books: { $ifNull: [&quot;$books&quot;, []]}, } } db.authors.aggregate([ getAuthorsWithBooks, ]) ","keywords":"","version":"当前版本"},{"title":"🦸‍♂️ 聚合选项","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/aggregation-options","content":"🦸‍♂️ 聚合选项 信息 额外活动：如果您有额外的时间或在家跟着做，可以尝试，导师不会在动手实验中进行讲解 危险 以下语法在 Atlas UI 聚合编辑器中不起作用。 我们可以传递一个带有一些选项的文档给 aggregate。 let options = { maxTimeMS: 100 }; db.authors.aggregate([], options); 💻 你可以传递给 aggregate 方法不同选项，查看 文档。 💻 尝试使用 10 毫秒的时间限制启动一个 itcount（一个长操作）来遍历整个 books 游标：你应该看到操作超时并失败。 let options = { maxTimeMS: 10 }; db.authors.aggregate([], options).itcount(); &gt; MongoServerError: operation exceeded time limit ","keywords":"","version":"当前版本"},{"title":"👐 组合阶段","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/combining-them-all","content":"👐 组合阶段 到目前为止，我们只在管道中使用了一个阶段。但聚合管道的强大之处在于我们可以使用多个阶段，一个阶段的输出将成为下一个阶段的输入。可以把它想象成 UNIX 管道或使用带有 map、filter、reduce、flatmap 等的函数式编程。 获取 2001 年 200 页的 10 本书。只显示标题和作者。 Atlas UIMongoDB Shell [ { $match: { year: 2001, pages: 200 } }, { $project: { _id: 0, title: 1, authors: 1 } }, { $limit: 10 }, ] 👐 获取 1985 年 150 页的 15 本书。只显示 title、year、totalInventory 和 available 字段。如果你不记得有哪些字段，可以参考示例文档。 答案 Atlas UIMongoDB Shell [ { $match: { year: 1985, pages: 150 } }, { $project: { _id: 0, title: 1, year: 1, totalInventory: 1, available: 1 } }, { $limit: 15 }, ] ","keywords":"","version":"当前版本"},{"title":"👐 排序","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/counting-sorting/sorting","content":"👐 排序 我们可以使用$sort阶段对结果进行排序。我们需要对字段进行排序，1表示升序，-1表示降序。 👐 让我们获取所有1984年的书籍，并按页数排序。我们只显示标题、页数和作者。 let booksFrom1984 = {$match: {year: 1984}}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, pages: 1, authors: 1}}; let slimmerBooksFirst = {$sort: {&quot;pages&quot;: 1}} db.books.aggregate([ booksFrom1984, showOnlyTheseFields, slimmerBooksFirst, ]); 如我们所见，没有pages信息的书籍首先出现。这些文档没有该信息，因此pages为null，并被排序为小于任何数字。 👐 我们可以反过来排序： let booksFrom1984 = {$match: {year: 1984}}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, pages: 1, authors: 1}}; let thickerBooksFirst = {$sort: {&quot;pages&quot;: -1}} db.books.aggregate([ booksFrom1984, showOnlyTheseFields, thickerBooksFirst, ]); 👐 我们如何获取1984年最厚的书？ 答案 let booksFrom1984 = {$match: {year: 1984}}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, pages: 1, authors: 1}}; let thickerBooksFirst = {$sort: {&quot;pages&quot;: -1}} let justOne = {$limit: 1} db.books.aggregate([ booksFrom1984, showOnlyTheseFields, thickerBooksFirst, justOne ]); ","keywords":"","version":"当前版本"},{"title":"👐 空聚合管道","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/empty-aggregation","content":"","keywords":"","version":"当前版本"},{"title":"一个空的聚合​","type":1,"pageTitle":"👐 空聚合管道","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/empty-aggregation#一个空的聚合","content":" 这段代码相当于 SELECT * FROM AUTHORS。返回一个包含 authors 集合中所有文档的 游标（cursor）：  Atlas UIMongoDB Shell 打开 Aggregation 选项卡。选择 Text。输入如下一个空数组，注意编辑器中的空数组表示一个空的聚合管道： []  ","version":"当前版本","tagName":"h2"},{"title":"👐 $limit","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/limiting-results","content":"👐 $limit 如果我们返回了太多的文档，但我们只对其中的一部分感兴趣，我们可以使用 $limit 来限制返回的文档数量。 Atlas UIMongoDB Shell [ { $limit: 1 } ] 这只返回一个文档。 👐 只返回 7 本 books。 答案 Atlas UIMongoDB Shell [ { $limit: 7 } ] ","keywords":"","version":"当前版本"},{"title":"🦸‍♂️ 重复阶段","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/repeating-stages","content":"🦸‍♂️ 重复阶段 信息 额外活动：如果您有额外的时间或在家跟着做，可以尝试，导师不会在动手实验中进行讲解 从 Aggregation Pipelines 手册 中引用： 除了 $out, $merge, $geoNear, $changeStream 和 $changeStreamSplitLargeEvent 阶段外，其他所有阶段都可以在一个管道中多次出现。 因此我们可以重复大多数阶段，并做类似于以下操作，以获取1985年且页数超过100页的所有书籍（尽管这可能有意义或没有意义） Atlas UIMongoDB Shell [ { $match: { pages: {$gte: 100} } }, { $match: { year: 1985 } } ] 💻 在上述聚合的末尾添加几个 $limit 阶段，限制为1本书，看看会发生什么 答案 Atlas UIMongoDB Shell [ {$match: {pages: {$gte: 100}}}, {$match: {year: 2011}}, {$limit: 1}, {$limit: 1}, ] ","keywords":"","version":"当前版本"},{"title":"👐 使用图书馆数据库","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/using-library-database","content":"","keywords":"","version":"当前版本"},{"title":"选择图书馆数据库​","type":1,"pageTitle":"👐 使用图书馆数据库","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/using-library-database#选择图书馆数据库","content":" 💻 我们将在此实验中使用 library 数据库进行所有实践练习。 如果您还没有执行前置数据导入操作，请将图书馆数据导入到您的数据库集群中。  Atlas UIMongoDB Shell 在聚合管道构建器中选择正确的数据库。 ","version":"当前版本","tagName":"h2"},{"title":"🎯 总结","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/summary","content":"🎯 总结 恭喜！通过本教程，您已经成功地： 使用聚合管道框架查找符合条件的文档使用聚合管道执行分组、转换和聚合操作从管道中导出数据 后续您可以访问 MongoDB 开发者中心 获取更多有用的信息和教程。","keywords":"","version":"当前版本"},{"title":"👐 $match","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/match","content":"","keywords":"","version":"当前版本"},{"title":"表达式​","type":1,"pageTitle":"👐 $match","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/match#表达式","content":" $match 操作符中的 &lt;expression&gt; 部分可以是任何有效的 MongoDB 表达式。这包括：  比较操作符：eq、neq、gte、lte、gt、lt、in、nin、exists正则表达式：regex逻辑操作符：and、or、not子文档和数组：{ field: &lt;value&gt; }, [ &lt;item&gt;, &lt;item&gt;, ... ]  ","version":"当前版本","tagName":"h2"},{"title":"匹配书籍文档​","type":1,"pageTitle":"👐 $match","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/match#匹配书籍文档","content":" Atlas UIMongoDB Shell 首先，确保在 Atlas UI 中选择 books 集合。 然后，导航到 Aggregation 选项卡并点击 Add Stage。 假设我们想要所有 2010 年的书籍。我们可以添加一个 $match 阶段来过滤 books 集合中的文档： [ { $match: { year: 2010 } } ]   👐 返回所有有恰好 100 页的 books。  答案 Atlas UIMongoDB Shell [ { $match: { pages: 100 } } ]   ","version":"当前版本","tagName":"h2"},{"title":"AND​","type":1,"pageTitle":"👐 $match","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/match#and","content":" 如果我们需要使用 AND 添加更多条件，可以使用 $and 操作符。  如果我们想要所有有 100 页并且 totalInventory 恰好为 2 的书籍，我们可以使用 $and 操作符。这个操作符接受一个包含所有条件的文档数组，这些条件都必须为真，AND 操作才会成功：  Atlas UIMongoDB Shell [ { $match: { $and: [ { pages: 100 }, { totalInventory: 2 } ] } } ]   伪代码如下：  IF pages == 100 AND totalInventory == 2 { return matching docs }   👐 返回所有 2015 年的 books，这些书籍恰好有 100 页。  答案 Atlas UIMongoDB Shell [ { $match: { $and: [ { pages: 100 }, { year: 2015 } ] } } ]   👐 它们有多少？  答案 Atlas UIMongoDB Shell [ { $match: { $and: [ { pages: 100 }, { year: 2015 } ] } }, { $count: &quot;books_count&quot; } ]   ","version":"当前版本","tagName":"h2"},{"title":"简写 AND​","type":1,"pageTitle":"👐 $match","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/match#简写-and","content":" 我们可以通过传递包含所有条件的文档来进行隐式 AND（而不是文档数组）：  Atlas UIMongoDB Shell [ { $match: {pages: 100, totalInventory: 2} } ]   👐 使用简单的 $and 语法返回所有 2015 年的 books，这些书籍恰好有 100 页  答案 Atlas UIMongoDB Shell [ { $match: {pages: 100, year: 2015} } ]  ","version":"当前版本","tagName":"h3"},{"title":"👐 编写长管道","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/writing-long-pipelines","content":"👐 编写长管道 聚合管道可能会变得很长，这取决于我们需要运行多少阶段。编写管道就是编写代码，因为你将使用你自己熟悉的编程语言中的 MongoDB 驱动程序（SDK）来编写它。这里我们使用适用于 MongoDB Shell mongosh 的 JavaScript 示例。但如果你在用 Rust 编写一个微服务，你肯定会用 Rust 编写你的管道，其他编程语言同理。 危险 以下语法在 Atlas UI 聚合编辑器中不能使用。UI 编辑器不支持声明变量。 这就是为什么我们应该像这样重写我们最后的管道： 获取 1985 年有 150 页的 15 本书。仅显示 title、year、totalInventory 和 available 字段。 (示例文档 这里) db.books.aggregate([ {$match: {year: 1985, pages: 150}}, {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}, {$limit: 15} ]) 将被更改为： let booksFrom1985With150pages = {$match: {year: 1985, pages: 150}}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}; let getJust15books = {$limit: 15}; db.books.aggregate([ booksFrom1985With150pages, showOnlyTheseFields, getJust15books, ]); 更改后更容易阅读和理解，对吧？ 👐 尝试运行上述管道并比较你的结果：应该与之前相同 提示 您可以像在编程语言中组合函数一样编写你的聚合管道。聚合 是 服务器上运行的代码。在客户端你只是表达 需要 做什么，而不是 如何 进行操作。 提示 由于这是代码，我们甚至可以在管道中添加注释（以 // 开头） 👐 我们还可以使用 $gte 获取 150 页或更多的书。检查 文档 中的 $gte 语法，并编写一个聚合管道以返回 1985 年超过 150 页的 15 本书。仅显示 title、year、totalInventory 和 available 字段。 (示例文档 这里) 提示: 我们需要使用 $and，因为这可能有点复杂。 答案 let moreThan150pages = {pages: {$gte: 150}} let booksFrom1985WithMoreThan150pages = {$match: {$and: [{year: 1985}, moreThan150pages]}}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}; let getJust15books = {$limit: 15}; db.books.aggregate([ booksFrom1985WithMoreThan150pages, showOnlyTheseFields, getJust15books, ]); ","keywords":"","version":"当前版本"},{"title":"👐 简单数组查询","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/using-arrays/simple-match-array","content":"","keywords":"","version":"当前版本"},{"title":"👐 $project","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/project","content":"","keywords":"","version":"当前版本"},{"title":"在输出中包括特定字段​","type":1,"pageTitle":"👐 $project","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/project#在输出中包括特定字段","content":" books 集合中的文档如下所示：  { _id: '0395623650', title: 'Platero y yo / Platero and I (Spanish-English Bilingual Edition) (English and Spanish Edition)', authors: [ { _id: '64cc2db4830ba29148db5180', name: 'Juan Ramón Jiménez' } ], pages: 64, year: 1994, synopsis: 'Selections from a classic of world literature present a picture of life in the town of Moguer, in Andalusia, Spain.\\n' + '\\n' + '\\n' + ' Presents a picture of life in the town of Moguer, in Andalusia, Spain, as seen through the eyes of a wandering poet and his faithful donkey.\\n', cover: 'https://images.isbndb.com/covers/36/57/9780395623657.jpg', attributes: [ { key: 'edition', value: 'F First Edition Thus' }, { key: 'dimensions', value: 'Height: 10.499979 Inches, Length: 6.999986 Inches, Weight: 2.0502990366 Pounds, Width: 0.12499975 Inches' }, { key: 'isbn13', value: '9780395623657' }, { key: 'msrp', value: 1.99 }, { key: 'isbn', value: '0395623650' }, { key: 'isbn10', value: '0395623650' } ], totalInventory: 1, available: 1, binding: 'Hardcover', language: 'en', longTitle: 'Platero y yo / Platero and I (Spanish-English Bilingual Edition) (English and Spanish Edition)', publisher: 'Clarion Books' }   如果我们只对书名感兴趣，我们可以使用 $project 选择我们感兴趣的字段。例如，要只获取书名和年份，我们可以这样写：  Atlas UIMongoDB Shell [ { $project: {title: 1, year: 1} } ]   1 表示“显示该字段”0 表示“隐藏该字段”主键 _id 字段默认显示  所以我们可以排除字段，并显示除 attributes 之外的所有字段：  Atlas UIMongoDB Shell [ { $project: {attributes: 0} } ]   👐 仅显示 title 和 cover。  答案 Atlas UIMongoDB Shell [ { $project: {title: 1, cover: 1} } ]   ","version":"当前版本","tagName":"h2"},{"title":"排除字段​","type":1,"pageTitle":"👐 $project","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/project#排除字段","content":" 👐 从结果中排除 cover、attributes 和 _id 字段。  答案 Atlas UIMongoDB Shell [ { $project: {_id: 0, attributes: 0, cover: 0} } ]   ","version":"当前版本","tagName":"h2"},{"title":"包括和排除字段​","type":1,"pageTitle":"👐 $project","url":"/aggregation-pipeline-lab/zh/docs/simple-queries/project#包括和排除字段","content":" 危险 在同一个 $project 中不能同时包括和排除字段：如果你开始包括字段，你必须一直包括字段，反之亦然。  例如，这将失败：  db.books.aggregate([{$project: {title: 1, attributes: 0}}]) MongoServerError: Invalid $project :: caused by :: Cannot do exclusion on field attributes in inclusion projection   信息 这个规则的唯一例外是 _id 字段，我们可以在包括字段的 $project 中排除它。  db.books.aggregate([{$project: {title: 1, _id: 0}}])  ","version":"当前版本","tagName":"h2"},{"title":"👐 在数组中的对象内搜索","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/using-arrays/search-inside-objects-in-arrays","content":"👐 在数组中的对象内搜索 在我们的书籍中，我们使用了 Attribute Pattern 来在文档中拥有不同的属性。正如我们在 样本文档 中看到的，我们有一个attributes数组，包含几个对象，每个对象具有相同的结构： attributes: [ { key: 'edition', value: '1st' }, { key: 'dimensions', value: 'Height: 1.111 Inches, Length: 1.111 Inches, Weight: 0.2 Pounds, Width: 1.111 Inches' }, { key: 'isbn13', value: '9780765342508' }, { key: 'msrp', value: 6.99 }, { key: 'isbn', value: '0765342502' }, { key: 'isbn10', value: '0765342502' } ], 我们如何搜索所有售价为9.99的书籍？我们想要在attributes中有一个对象，其键为msrp且值为9.99的书籍。我们可以使用以下方式实现： db.books.aggregate([ { $unwind : &quot;$attributes&quot; }, {$match: {&quot;attributes.key&quot;: &quot;msrp&quot;, &quot;attributes.value&quot;: 9.99} }, {$project: {title: 1, attributes: 1}} ]); 在这里，我们为$attributes数组中的每个对象获取每本书的副本。这将&quot;展开&quot;数组并返回相同文档的多个副本，每个副本具有不同的属性，这些属性对于每个生成的文档都是不同的。 👐 为了更好地理解$unwind，运行此聚合 db.books.aggregate([ { $match: {_id: &quot;0395623650&quot;} }, { $unwind : &quot;$attributes&quot; }, ]); 你应该会为原书的每个属性获取一个文档。 但你实际上可以更直接地匹配数组中的文档： let nineNinetyNine = {$match: {&quot;attributes.key&quot;: &quot;msrp&quot;, &quot;attributes.value&quot;: 9.99}}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1, &quot;attributes&quot;: 1}}; db.books.aggregate([ nineNinetyNine, showOnlyTheseFields, ]); ","keywords":"","version":"当前版本"},{"title":"在数组中查找数据​","type":1,"pageTitle":"👐 简单数组查询","url":"/aggregation-pipeline-lab/zh/docs/using-arrays/simple-match-array#在数组中查找数据","content":" 一个 JSON 数组可以包含标量值或对象。在我们的数据中，authors 有一个包含他们创作的书籍（他们的 ISBN）的数组。让我们获取一个作者：  db.authors.aggregate([{$limit: 1}])   👐 运行此聚合以获取一个作者  我得到了这个（可能会根据你导入的数据源而变化）  { _id: ObjectId(&quot;64cc2db4830ba29148da4c3b&quot;), name: 'Richard Bruce Wright', sanitizedName: 'richardbrucewright', books: [ '0002005018' ], aliases: [ 'Wright, Richard Bruce' ] }   我能获取书籍 0002005018 的所有作者吗？为此，我想要所有在 books 数组中包含 0002005018 的作者。事实证明这非常简单：  db.authors.aggregate([ {$match: {books: &quot;0002005018&quot;}} ])   👐 获取 ISBN 为 0395623650 的书籍的作者姓名：  答案 db.authors.aggregate([{$match: {books: &quot;0395623650&quot;}}]) &gt; name: 'Juan Ramón Jiménez',   ","version":"当前版本","tagName":"h2"},{"title":"数组的大小​","type":1,"pageTitle":"👐 简单数组查询","url":"/aggregation-pipeline-lab/zh/docs/using-arrays/simple-match-array#数组的大小","content":" 如果我们想知道一个作者有多少本书怎么办？为此我们可以使用 $size，添加我们需要知道大小的数组字段：  db.authors.aggregate([ {$project: { name: 1, bookCount: {$size: &quot;$books&quot;} } }, ])   👐 谁写的书最多？（我们可以使用 { $sort: {&quot;bookCount&quot;: -1}} 进行排序）  答案 let addNumberBooks = { $project: { name: 1, bookCount: {$size: &quot;$books&quot;} } } let orderByNumberOfBooksDesc = { $sort: {&quot;bookCount&quot;: -1}} let getOne = {$limit: 1} db.authors.aggregate([ addNumberBooks, orderByNumberOfBooksDesc, getOne, ])  ","version":"当前版本","tagName":"h2"},{"title":"📘 什么是聚合管道","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/what-is-aggregation/what-is-aggregation","content":"📘 什么是聚合管道 聚合管道类似于使用管道连接的 Unix 命令。 我们可以构建模块化、可组合的处理管道。 一个聚合管道由一个或多个处理文档的 阶段(stage) 组成： 每个阶段对输入文档执行一个操作。例如，一个阶段可以过滤文档、分组文档和计算值。 一个阶段的输出文档被作为输入，并传递给下一个阶段。 聚合管道可以返回文档组的结果。例如，返回总值、平均值、最大值和最小值等。","keywords":"","version":"当前版本"},{"title":"📘 SQL 与聚合","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/what-is-aggregation/sql-vs-aggregation","content":"","keywords":"","version":"当前版本"},{"title":"SQL​","type":1,"pageTitle":"📘 SQL 与聚合","url":"/aggregation-pipeline-lab/zh/docs/what-is-aggregation/sql-vs-aggregation#sql","content":" 一个 SQL 查询语句通常以 SELECT 开始，在这里我们列出所需的字段，然后是 FROM 子句来指定将返回行的表（或在本例中为子查询）。我们可以使用 WHERE 进行筛选，并使用 GROUP 对数据进行分组。  我们从读取 SQL 需从嵌套中理解整个语句的含义。如果嵌套过多，则不易理解。  SELECT city, SUM(annual_spend) Total_Spend, AVG(annual_spend) Average_Spend, MAX(annual_spend) Max_Spend, COUNT(annual_spend) customers FROM ( SELECT t1.city, customer.annual_spend FROM customer LEFT JOIN ( SELECT address.address_id, city.city, address.customer_id, address.location FROM address LEFT JOIN city ON address.city_id = city.city_id ) AS t1 ON (customer.customer_id = t1.customer_id AND t1.location = &quot;home&quot;) ) AS t2 GROUP BY city;   ","version":"当前版本","tagName":"h2"},{"title":"等效的 MongoDB 聚合管道​","type":1,"pageTitle":"📘 SQL 与聚合","url":"/aggregation-pipeline-lab/zh/docs/what-is-aggregation/sql-vs-aggregation#等效��的-mongodb-聚合管道","content":" 在这里我们通过三个阶段，一个返回 address 数组中每个元素的文档，然后我们筛选出仅包含 home 地址位置的文档，最后我们进行分组。正如我们将动手实践并看到的，MongoDB 聚合管道可以分开测试，并且运行逻辑类似于我们的代码结构本身。  db.customers.aggregate([ { $unwind: &quot;$address&quot;, }, { $match: {&quot;address.location&quot;: &quot;home&quot;} }, { $group: { _id: &quot;$address.city&quot;, totalSpend: {$sum: &quot;$annualSpend&quot;}, averageSpend: {$avg: &quot;$annualSpend&quot;}, maximumSpend: {$max: &quot;$annualSpend&quot;}, customers: {$sum: 1} } } ])   信息 另请参阅 SQL 与聚合映射表 ","version":"当前版本","tagName":"h2"},{"title":"📘 聚合管道的结构","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/zh/docs/what-is-aggregation/structure-aggregation","content":"","keywords":"","version":"当前版本"},{"title":"示例​","type":1,"pageTitle":"📘 聚合管道的结构","url":"/aggregation-pipeline-lab/zh/docs/what-is-aggregation/structure-aggregation#示例","content":" 一个执行上述 SQL 语句的聚合管道示例如下：  db.mycollection.aggregate([ { $sort: /** * 提供任意数量的字段/排序对。 */ { num_mflix_comments: -1, }, }, { $limit: /** * 提供要限制的文档数量。 */ 1, }, { $unwind: /** * path: 数组字段的路径。 * includeArrayIndex: 索引名称（可选）。 * preserveNullAndEmptyArrays: 展开 null 和空值（可选）。 */ { path: &quot;$cast&quot;, }, }, { $project: /** * 规范：要包含或排除的字段。 */ { cast: 1, }, }, ])  ","version":"当前版本","tagName":"h2"}],"options":{"languages":["en","zh"],"id":"default"}}