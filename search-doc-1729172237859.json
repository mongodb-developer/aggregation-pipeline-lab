{"searchDocs":[{"title":"ü¶∏ Saving to a Collection","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/exporting-data/saving-to-collection","content":"ü¶∏ Saving to a Collection You can export the result of an aggregation pipeline to a different DB/collection. To do that, just add a last aggregation stage to your pipeline: Atlas UIMongoDB Shell Run this from the source collection [{ $out: { db: &quot;&lt;output-db&gt;&quot;, coll: &quot;&lt;output-collection&gt;&quot; } }] You can omit the db attribute, and the new collection will be created in the current DB. { $out: &quot;&lt;output-collection&gt;&quot; } üëê Create a copy of the books with exactly 100 pages and output as a new collection named OneHundredPagesBooks. Answer Atlas UIMongoDB Shell [ {$match: {pages: 100}}, {$out: &quot;OneHundredPagesBooks&quot;} ] After running this, we should see a new collection with: show collections ","keywords":"","version":"Next"},{"title":"Intro","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/intro","content":"Intro Lab goals\tLearn about aggregation pipelines writing aggregation pipelinesWhat you'll learn\tWhat are aggregation pipelines? How are they different from simple MongoDB queries or SQL? How to use simple pipelines to get data, filter it, show the fields needed How to write more advanced pipelines, querying arrays, counting and sorting results How to do JOINs using $lookup How to group data Exporting data How to write aggregations using popular programming languages (TBD) Time to complete\t90 mins In the navigation bar and on some pages, you will notice some icons. Here are their meanings: Icon\tMeaningüìò\tLecture material - If you're following along in an instructor-led session, they probably have covered this already. üëê\tHands-on content - Get ready to get some work done. You should follow these steps. üí¨\tDiscussion - Item to discuss during the lab ü¶∏\tAdvanced content - This content isn't covered during the lab, but if you're interested in learning more, you can check it out.","keywords":"","version":"Next"},{"title":"üìò Lecture material","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/lecture-material","content":"","keywords":"","version":"Next"},{"title":"Aggregation pipeline cheatsheet‚Äã","type":1,"pageTitle":"üìò Lecture material","url":"/aggregation-pipeline-lab/docs/lecture-material#aggregation-pipeline-cheatsheet","content":"   Unable to display PDF file. Download instead. ","version":"Next","tagName":"h2"},{"title":"üëê Sorting","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/counting-sorting/sorting","content":"üëê Sorting We can sort our results using the $sort stage. We need to sort on a field, with 1 being ascending and -1 descending order. üëê Let's get all books from 1984, sorted by number of pages. We'll only show the title, pages, and authors. Atlas UIMongoDB Shell [ {$match: {year: 1984}}, {$project: {_id: 0, title: 1, pages: 1, authors: 1}}, {$sort: {&quot;pages&quot;: 1}}, ] As we can see, books with no pages info appear first. These documents don't have that information. Hence, pages is null and gets sorted as less than any number. üëê We can sort the other way around: Atlas UIMongoDB Shell [ {$match: {year: 1984}}, {$project: {_id: 0, title: 1, pages: 1, authors: 1}}, {$sort: {&quot;pages&quot;: -1}}, ] üëê How can we get the thickest book from 1984? Answer Atlas UIMongoDB Shell [ {$match: {year: 1984}}, {$project: {_id: 0, title: 1, pages: 1, authors: 1}}, {$sort: {&quot;pages&quot;: -1}}, {$limit: 1} ] ","keywords":"","version":"Next"},{"title":"üëê $count","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/counting-sorting/counting-documents","content":"","keywords":"","version":"Next"},{"title":"The order of stages is important‚Äã","type":1,"pageTitle":"üëê $count","url":"/aggregation-pipeline-lab/docs/counting-sorting/counting-documents#the-order-of-stages-is-important","content":" If we count after the $match stage, the document we're passing to the next steps contains only the totalBooks field. So the $project stage will return an empty document.  Atlas UIMongoDB Shell [ {$match: {$and: [{year: 1985}, {pages: {$gte: 150}} ]}}, {$count: &quot;totalBooks&quot;}, {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}, {$limit: 15}, ]  ","version":"Next","tagName":"h2"},{"title":"üëê Group","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/grouping/group","content":"üëê Group We can sum all the pages for all books in each year: Atlas UIMongoDB Shell [ {$group:{ _id: &quot;$year&quot;, totalPages: {$sum: &quot;$pages&quot;} }} ] Here, we group by the book's year (the _id of the grouping), and then we create a new field called totalPages that's the sum of all pages. üëê Can you get the results ordered ascending by year? Answer Atlas UIMongoDB Shell [ {$group:{ _id: &quot;$year&quot;, totalPages: {$sum: &quot;$pages&quot;} }}, {$sort: {_id: 1}} ] üëê Can you get the average pages per year (hint: use $avg)? Answer Atlas UIMongoDB Shell [ {$group:{ _id: &quot;$year&quot;, totalPages: {$avg: &quot;$pages&quot;} }}, {$sort: {_id: 1}} ] üëê Which year had the most printed-out pages? Answer Atlas UIMongoDB Shell [ {$group:{ _id: &quot;$year&quot;, totalPages: {$sum: &quot;$pages&quot;} }}, {$sort: {totalPages: -1}}, {$limit: 1} ] ","keywords":"","version":"Next"},{"title":"üëê Lookups, AKA Left Outer Join","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/lookups/lookups","content":"","keywords":"","version":"Next"},{"title":"Lookups from a previous stage‚Äã","type":1,"pageTitle":"üëê Lookups, AKA Left Outer Join","url":"/aggregation-pipeline-lab/docs/lookups/lookups#lookups-from-a-previous-stage","content":" We can do a $lookup on the result of another pipeline, not only joining with a collection. For instance, we want to remove some noise from the books before joining, so we use $project to exclude a couple of arrays.  Atlas UIMongoDB Shell [ {$lookup: { from: &quot;books&quot;, localField: &quot;books&quot;, foreignField: &quot;_id&quot;, pipeline: [ {$project: {title: 1, synopsis: 1}} ], as: &quot;booksWritten&quot; } } ]   The nice part is that we can extract that pipeline and test it/tweak it. (This will only work in the MongoDB Shell)  MongoDB Shell let justShowTitleSynopsis = [ {$project: {title: 1, synopsis: 1}}, ] db.authors.aggregate([ {$lookup: { from: &quot;books&quot;, localField: &quot;books&quot;, foreignField: &quot;_id&quot;, pipeline: justShowTitleSynopsis, as: &quot;booksWritten&quot; } } ])  ","version":"Next","tagName":"h2"},{"title":"ü¶∏‚Äç‚ôÇÔ∏è Advanced lookups","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/lookups/advanced-lookups","content":"ü¶∏‚Äç‚ôÇÔ∏è Advanced lookups info Extra activity! Do it if you have extra time or are following along at home. It won't be covered during the hands-on lab. We get this request: Write a $lookup to get name and bio from author's information inside each book document. To get this done, we need to review several things: Each book can have several authors. This many-to-many relationship (as an author can also write many books) is modeled using two different arrays: a books array in the authors collection and an authors array in the books collection.So we'll need to get a separate document for each book that has more than one author. If a book has three authors, we'll use $unwind to get three documents with the same data except for the author, which will be each of the three authors. You can try this with this aggregation pipeline: Atlas UIMongoDB Shell [ // as a book can have many authors, we get one doc per book's author {$unwind: &quot;$authors&quot;}, // remove some noisy fields {$project: {attributes: 0, reviews: 0}} ] Now, we need to get the authors' information. For that, we'll use $lookup, linking the _id in the authors collection with the _id we have in each book's authors array. But as we can see here, these have a different type: The ones inside our array are strings, while the author collection _id are ObjectId. authors: { _id: '64cc2db4830ba29148da64a2', name: 'Timothy Findley' }, So we need to convert from String into ObjectId. We can do that using $toObjectId. This will add a new field, authorId, converting it into ObjectId: Atlas UIMongoDB Shell [ // as a book can have many authors, we get one doc per book's author {$unwind: &quot;$authors&quot;}, // convert it to an objectId {&quot;$set&quot;:{&quot;authorId&quot;:{&quot;$toObjectId&quot;:&quot;$authors._id&quot;}}}, // remove some noisy fields {$project: {attributes: 0, reviews: 0}} ] Now, we're ready to do the $lookup: We want all documents from authors that have the same _id as the authorId we just created. We use a pipeline to get just authors name and bio. Atlas UIMongoDB Shell [ // as a book can have many authors, we get one doc per book's author {$unwind: &quot;$authors&quot;}, // convert it to an objectId {&quot;$set&quot;:{&quot;authorId&quot;:{&quot;$toObjectId&quot;:&quot;$authors._id&quot;}}}, {$lookup: { from: &quot;authors&quot;, localField: &quot;authorId&quot;, foreignField: &quot;_id&quot;, pipeline: [ {$project: {name: 1, bio: 1}}, ], as: &quot;bookAuthorDetails&quot; } }, // remove some noisy fields {$project: {attributes: 0, reviews: 0}} ] ","keywords":"","version":"Next"},{"title":"ü¶∏ Missing Data","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/modifying-results/missing-data","content":"ü¶∏ Missing Data Sometimes, we're missing a field we're looking for (it's not there, as documents in a collection can be polymorphic, so this field is null). For these cases, we can check if something is there using $ifNull and add a default value. Atlas UIMongoDB Shell [ { $project: { name: 1, books: { $ifNull: [&quot;$books&quot;, []]}, } } ] ","keywords":"","version":"Next"},{"title":"üëê Adding New Fields to Results","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/modifying-results/adding-fields","content":"","keywords":"","version":"Next"},{"title":"$addFields‚Äã","type":1,"pageTitle":"üëê Adding New Fields to Results","url":"/aggregation-pipeline-lab/docs/modifying-results/adding-fields#addfields","content":" We want to estimate the reading time for a book. But we don't have that field stored in our data. We can use $addFields for this. If the field exists, it'll get updated, and if it doesn't, it's added.  Atlas UIMongoDB Shell [ {$project: { title: 1, pages: 1, } }, {$addFields: {readingTimeHours: {$divide: [{$multiply: [&quot;$pages&quot;, 2]}, 60]}}}, ]   üëê Add a new field, notes, that contains the text PLACEHOLDER for all documents.  Answer Atlas UIMongoDB Shell [ {$project: { title: 1, pages: 1, } }, {$addFields: {notes: &quot;PLACEHOLDER&quot;}} ] info $set is an alias for $addFields that you'll find on many older posts and documentation. ","version":"Next","tagName":"h2"},{"title":"ü¶∏‚Äç‚ôÇÔ∏è Aggregation options","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/aggregation-options","content":"ü¶∏‚Äç‚ôÇÔ∏è Aggregation options info Extra activity! Do it if you have extra time or are following along at home. It won't be covered during the hands-on lab. danger The following syntax doesn't work in the Atlas UI aggregations editor. The editor doesn't support declaring variables. You can try this using the built-in MongoDB Shell in MongoDB Compass. We can pass a document to aggregate with some options. MongoDB Shell let options = { maxTimeMS: 100 }; db.authors.aggregate([], options); üíª Have a look at the different options you can pass to the aggregate method. üíª Try to launch an itcount (a long operation) to iterate through the whole books cursor with a time limit of 10 ms. You should see the operation timing out and failing. MongoDB Shell let options = { maxTimeMS: 10 }; db.authors.aggregate([], options).itcount(); &gt; MongoServerError: operation exceeded time limit ","keywords":"","version":"Next"},{"title":"üëê Combining stages","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/combining-them-all","content":"üëê Combining stages Up until now, we've just been using one stage in the pipeline. But the power of the aggregation pipeline is that we can use many stages, and the output of one will be the input of the next. Think of it as UNIX pipes or using functional programming with map, filter, reduce, flatmap, etc. Get 5 books from 2001 with more than 50 pages. Show only the title and authors. Atlas UIMongoDB Shell [ { $match: { year: 2001, pages: {$gt: 50 } } }, { $project: { _id: 0, title: 1, authors: 1 } }, { $limit: 5 }, ] We're using here the greater than $gt operator. You have $gt, $gte, $lt, etc. üëê Get 15 books from 1985 with less than 150 pages. Show only the title, year, totalInventory, and available books. If you don't remember which fields we have, you can refer to the sample document. Answer Atlas UIMongoDB Shell [ { $match: { year: 1985, pages: { $lt: 150 } } }, { $project: { _id: 0, title: 1, year: 1, totalInventory: 1, available: 1 } }, { $limit: 15 }, ] ","keywords":"","version":"Next"},{"title":"üëê Empty Aggregation Pipeline","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/empty-aggregation","content":"","keywords":"","version":"Next"},{"title":"An empty aggregation‚Äã","type":1,"pageTitle":"üëê Empty Aggregation Pipeline","url":"/aggregation-pipeline-lab/docs/simple-queries/empty-aggregation#an-empty-aggregation","content":" This code is the equivalent of a SELECT * FROM AUTHORS. It returns a cursor with all documents in the authors collection:  Atlas UIMongoDB Shell Make sure Collections &gt; authors is selected.Open the Aggregation tab.Select Text.Notice the empty array in the editor denoting an empty aggregation pipeline: [] You're getting all documents in authors (although the Atlas UI is only showing a 10 documents sample) ","version":"Next","tagName":"h2"},{"title":"üëê Set Up Lab","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/mongodb-atlas/setup-lab","content":"üëê Set Up Lab To follow along, you'll need: A MongoDB Atlas account.Test data. In this case, this is book, author, and review data for a library management system. üëê To get both, open the intro lab and follow it (only takes 10-15 mins) to get your database ready. Return here when finished!","keywords":"","version":"Next"},{"title":"üëê $limit","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/limiting-results","content":"üëê $limit If we return too many documents but we're interested in only a few, we can limit the number of documents returned using $limit. Atlas UIMongoDB Shell [ { $limit: 1 } ] This returns just one document. üëê Return just 7 books. Answer Atlas UIMongoDB Shell [ { $limit: 7 } ] ","keywords":"","version":"Next"},{"title":"ü¶∏‚Äç‚ôÇÔ∏è Repeating Stages","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/repeating-stages","content":"ü¶∏‚Äç‚ôÇÔ∏è Repeating Stages info Extra activity! Do it if you have extra time or are following along at home. It won't be covered during the hands-on lab. From the aggregation pipelines manual: All stages except the $out, $merge, $geoNear, $changeStream, and $changeStreamSplitLargeEvent stages can appear multiple times in a pipeline. So we can repeat most stages, and do something like this to get all books from 1985 with more than 100 pages (although it may or may not make sense): Atlas UIMongoDB Shell [ { $match: { pages: {$gte: 100} } }, { $match: { year: 1985 } } ] üíª Add several $limit stages at the end of the above aggregation, limiting to 1 book, and see what happens. Answer Atlas UIMongoDB Shell [ {$match: {pages: {$gte: 100}}}, {$match: {year: 2011}}, {$limit: 1}, {$limit: 1}, ] ","keywords":"","version":"Next"},{"title":"üëê Using the Library Database","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/using-library-database","content":"","keywords":"","version":"Next"},{"title":"Select the library database‚Äã","type":1,"pageTitle":"üëê Using the Library Database","url":"/aggregation-pipeline-lab/docs/simple-queries/using-library-database#select-the-library-database","content":" üíª We'll use the library database for all of the hands-on exercises in this lab. If you haven't already, import the library data into your database cluster.  Atlas UIMongoDB Shell Select the correct database in the aggregation pipeline builder. ","version":"Next","tagName":"h2"},{"title":"üéØ Summary","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/summary","content":"üéØ Summary Congratulations! Following this tutorial, you have successfully: Found documents for a given set of criteria using the aggregation pipeline framework.Performed grouping, transformations, and aggregations using aggregation pipelines.Exported data from the pipeline. Visit the MongoDB Developer Center for more useful information and tutorials.","keywords":"","version":"Next"},{"title":"üëê Searching inside Objects in arrays","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/using-arrays/search-inside-objects-in-arrays","content":"üëê Searching inside Objects in arrays In our books, we're using the Attribute Pattern to have different attributes in our documents. As we can see in the sample doc, we have an attributes array, containing several objects, each with the same structure: attributes: [ { key: 'edition', value: '1st' }, { key: 'dimensions', value: 'Height: 1.111 Inches, Length: 1.111 Inches, Weight: 0.2 Pounds, Width: 1.111 Inches' }, { key: 'isbn13', value: '9780765342508' }, { key: 'msrp', value: 6.99 }, { key: 'isbn', value: '0765342502' }, { key: 'isbn10', value: '0765342502' } ], How do we search for all the books that have an msrp of 9.99? We want books that, inside attributes, have an object with key msrp and value 9.99. We can get it to work with this: Atlas UIMongoDB Shell [ { $unwind : &quot;$attributes&quot; }, { $match: {&quot;attributes.key&quot;: &quot;msrp&quot;, &quot;attributes.value&quot;: 9.99} }, { $project: {title: 1, attributes: 1} } ] Here we're getting a copy of each book for each object inside the $attributes array. This &quot;flattens&quot; the array and returns many copies of the same documents, one for each different attribute that we have which will be different for each of these generated docs. üëê To better understand $unwind, run this aggregation. Atlas UIMongoDB Shell You need to select the books collection. [ { $match: {_id: &quot;0395623650&quot;} }, { $unwind : &quot;$attributes&quot; }, ] You should get one document per attribute of the original book. All fields in these returned documents should be the same, except the ones in attributes. But you can actually match documents in an array in a more straightforward fashion: Atlas UIMongoDB Shell [ { $match: {&quot;attributes.key&quot;: &quot;msrp&quot;, &quot;attributes.value&quot;: 9.99} }, { $project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1, &quot;attributes&quot;: 1} } ] ","keywords":"","version":"Next"},{"title":"üëê $project","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/project","content":"","keywords":"","version":"Next"},{"title":"Including fields in a projection‚Äã","type":1,"pageTitle":"üëê $project","url":"/aggregation-pipeline-lab/docs/simple-queries/project#including-fields-in-a-projection","content":" A document from the books collection looks like:  { _id: '0395623650', title: 'Platero y yo / Platero and I (Spanish-English Bilingual Edition) (English and Spanish Edition)', authors: [ { _id: '64cc2db4830ba29148db5180', name: 'Juan Ram√≥n Jim√©nez' } ], pages: 64, year: 1994, synopsis: 'Selections from a classic of world literature present a picture of life in the town of Moguer, in Andalusia, Spain.\\n' + '\\n' + '\\n' + ' Presents a picture of life in the town of Moguer, in Andalusia, Spain, as seen through the eyes of a wandering poet and his faithful donkey.\\n', cover: 'https://images.isbndb.com/covers/36/57/9780395623657.jpg', attributes: [ { key: 'edition', value: 'F First Edition Thus' }, { key: 'dimensions', value: 'Height: 10.499979 Inches, Length: 6.999986 Inches, Weight: 2.0502990366 Pounds, Width: 0.12499975 Inches' }, { key: 'isbn13', value: '9780395623657' }, { key: 'msrp', value: 1.99 }, { key: 'isbn', value: '0395623650' }, { key: 'isbn10', value: '0395623650' } ], totalInventory: 1, available: 1, binding: 'Hardcover', language: 'en', longTitle: 'Platero y yo / Platero and I (Spanish-English Bilingual Edition) (English and Spanish Edition)', publisher: 'Clarion Books' }   If we're interested in the titles, we can use $project to select just the fields we're interested in. As an example, to get just the book's title and year, we'll write:  Atlas UIMongoDB Shell [ { $project: { title: 1, year: 1 } } ]   1 means &quot;show that field.&quot;. Once you started an inclusion projection you can't exclude other fields (you just keep adding the fields you want to see)0 means &quot;hide that field.&quot;. Once you started an exclusion projection you can't include other fields (you just keep adding the fields you don't want to see)The primary key _id field is shown by default.  So we can exclude fields and show all fields except attributes using:  Atlas UIMongoDB Shell [ { $project: { attributes: 0 } } ]   üëê Show only title and cover.  Answer Atlas UIMongoDB Shell [ { $project: { title: 1, cover: 1 } } ]   ","version":"Next","tagName":"h2"},{"title":"Excluding fields‚Äã","type":1,"pageTitle":"üëê $project","url":"/aggregation-pipeline-lab/docs/simple-queries/project#excluding-fields","content":" üëê Exclude the cover, attributes, and _id fields from the result.  Answer Atlas UIMongoDB Shell [ { $project: {_id: 0, attributes: 0, cover: 0} } ]   ","version":"Next","tagName":"h2"},{"title":"Including and excluding fields‚Äã","type":1,"pageTitle":"üëê $project","url":"/aggregation-pipeline-lab/docs/simple-queries/project#including-and-excluding-fields","content":" danger You can't include and exclude fields in the same projection. If you start including, you must keep including, and vice versa.  For instance, this will fail:  db.books.aggregate([{$project: {title: 1, attributes: 0}}]) MongoServerError: Invalid $project :: caused by :: Cannot do exclusion on field attributes in inclusion projection   info The only exception to this rule is the _id field, which we can exclude in an inclusion projection.  db.books.aggregate([{$project: {title: 1, _id: 0}}])  ","version":"Next","tagName":"h2"},{"title":"üìò SQL vs Aggregations","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation","content":"","keywords":"","version":"Next"},{"title":"SQL‚Äã","type":1,"pageTitle":"üìò SQL vs Aggregations","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation#sql","content":" A SQL query statement usually starts with a SELECT where we put a list of the fields we need, then a FROM clause to state the table/s (or in this case, the subquery) that will return the rows. We can filter out using WHERE and group data using GROUP.  We read this from the inside. If there's too much nesting, it's not easy to follow.  SELECT city, SUM(annual_spend) Total_Spend, AVG(annual_spend) Average_Spend, MAX(annual_spend) Max_Spend, COUNT(annual_spend) customers FROM ( SELECT t1.city, customer.annual_spend FROM customer LEFT JOIN ( SELECT address.address_id, city.city, address.customer_id, address.location FROM address LEFT JOIN city ON address.city_id = city.city_id ) AS t1 ON (customer.customer_id = t1.customer_id AND t1.location = &quot;home&quot;) ) AS t2 GROUP BY city;   ","version":"Next","tagName":"h2"},{"title":"Equivalent MongoDB aggregation pipeline‚Äã","type":1,"pageTitle":"üìò SQL vs Aggregations","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/sql-vs-aggregation#equivalent-mongodb-aggregation-pipeline","content":" Here we pass three stages: one to return one document per element in the address array, and then we filter out to get only the documents that have a home address location. Finally, we do the grouping. As we'll see, this can be split and tested separately and resembles our code.  db.customers.aggregate([ { $unwind: &quot;$address&quot;, }, { $match: {&quot;address.location&quot;: &quot;home&quot;} }, { $group: { _id: &quot;$address.city&quot;, totalSpend: {$sum: &quot;$annualSpend&quot;}, averageSpend: {$avg: &quot;$annualSpend&quot;}, maximumSpend: {$max: &quot;$annualSpend&quot;}, customers: {$sum: 1} } } ])   info See also SQL to Aggregation Mapping Chart ","version":"Next","tagName":"h2"},{"title":"ü¶∏‚Äç‚ôÇÔ∏è Writing Long Pipelines","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/writing-long-pipelines","content":"ü¶∏‚Äç‚ôÇÔ∏è Writing Long Pipelines info Extra activity! Do it if you have extra time or are following along at home. It won't be covered during the hands-on lab. Aggregation pipelines can get very long, depending on how many stages we need to run. Writing a pipeline is writing code, as you will write it using one of the many MongoDB drivers in your own language. Here we're presenting the examples using JavaScript suitable for the MongoDB shell mongosh, but if you are writing a microservice in Rust, you'll definitely write your pipelines in Rust. danger The following syntax doesn't work in the Atlas UI aggregations editor. The editor doesn't support declaring variables. You can try this using the built-in MongoDB Shell in MongoDB Compass. This is why we should rewrite our last pipeline like this: Get 15 books from 1985 with less than 150 pages. Show only the title, year, totalInventory, and available books (sample doc here). MongoDB Shell db.books.aggregate([ { $match: {year: 1985, pages: { $lt: 150 } } }, { $project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1} }, { $limit: 15 } ]) Will be changed into: let lessThan150 = { $lt: 150 }; let booksFrom1985With150pages = {$match: {year: 1985, pages: lessThan150 }}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}; let getJust15books = {$limit: 15}; db.books.aggregate([ booksFrom1985With150pages, showOnlyTheseFields, getJust15books, ]); Easier to read and understand, right? üëê Try to run the above pipeline and compare your results. They should be the same as before. tip Write your aggregation pipelines like you'll compose functions in your programming language. Aggregations are code that runs on the server. In the client, you just express what you want to be done, not how to do it. tip As this is code, we can even add comments (starting with //) to our pipelines. Or write functions that take parameters and return a stage. Or unit test our stages. üëê We can also use $gte to get the books with 150 pages or more. Check $gte syntax in the docucumentation and write an aggregation pipeline to return 15 books from 1985 with more than 150 pages. Show only the title, year, totalInventory, and available books (sample doc here). Answer let moreThan150pages = {pages: {$gte: 150}} let booksFrom1985WithMoreThan150pages = {$match: {$and: [{year: 1985}, moreThan150pages]}}; let showOnlyTheseFields = {$project: {_id: 0, title: 1, year: 1, totalInventory: 1, available: 1}}; let getJust15books = {$limit: 15}; db.books.aggregate([ booksFrom1985WithMoreThan150pages, showOnlyTheseFields, getJust15books, ]); ","keywords":"","version":"Next"},{"title":"üëê Simple Array Queries","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/using-arrays/simple-match-array","content":"","keywords":"","version":"Next"},{"title":"Find data in arrays‚Äã","type":1,"pageTitle":"üëê Simple Array Queries","url":"/aggregation-pipeline-lab/docs/using-arrays/simple-match-array#find-data-in-arrays","content":" A JSON array can contain scalar values or objects. In our data, authors have an array of the books they've authored (their ISBNs as Strings). Let's get one author:  Atlas UIMongoDB Shell Remember to select the authors collection in the UI. [ { $limit: 1 } ]   üëê Run this aggregation to get one author.  I got this one. (It can change depending on the data source you imported.)  { _id: ObjectId(&quot;64cc2db4830ba29148da4c3b&quot;), name: 'Richard Bruce Wright', sanitizedName: 'richardbrucewright', books: [ '0002005018' ], aliases: [ 'Wright, Richard Bruce' ] }   Can I get all authors for book 0002005018? For that, I want all authors that have 0002005018 inside the books array. Turns out it's quite simple:  Atlas UIMongoDB Shell [ {$match: {books: &quot;0002005018&quot;}} ]   üëê Get the book's author name for ISBN 0395623650:  Answer Atlas UIMongoDB Shell [ { $match: {books: &quot;0395623650&quot;} } ] &gt; name: 'Juan Ram√≥n Jim√©nez',   ","version":"Next","tagName":"h2"},{"title":"Size of an array‚Äã","type":1,"pageTitle":"üëê Simple Array Queries","url":"/aggregation-pipeline-lab/docs/using-arrays/simple-match-array#size-of-an-array","content":" What if we want to know how many aliases an author has? To do that, we can use $size, adding the array field that we're interested in:  Atlas UIMongoDB Shell [ { $project: { name: 1, bookCount: {$size: &quot;$books&quot;} } }, ]   üëê Who wrote the most books? (We can sort using { $sort: {&quot;bookCount&quot;: -1}}.)  Answer Atlas UIMongoDB Shell [ { $project: { name: 1, bookCount: {$size: &quot;$books&quot;} } }, { $sort: {&quot;bookCount&quot;: -1} }, { $limit: 1 } ]  ","version":"Next","tagName":"h2"},{"title":"üìò Structure of an Aggregation Pipeline","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/structure-aggregation","content":"","keywords":"","version":"Next"},{"title":"Example‚Äã","type":1,"pageTitle":"üìò Structure of an Aggregation Pipeline","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/structure-aggregation#example","content":" An aggregation pipeline that does the same as the above SQL statement could be:  db.mycollection.aggregate([ { $sort: /** * Provide any number of field/order pairs. */ { num_mflix_comments: -1, }, }, { $limit: /** * Provide the number of documents to limit. */ 1, }, { $unwind: /** * path: Path to the array field. * includeArrayIndex: Optional name for index. * preserveNullAndEmptyArrays: Optional * toggle to unwind null and empty values. */ { path: &quot;$cast&quot;, }, }, { $project: /** * Specifications: The fields to * include or exclude. */ { cast: 1, }, }, ])  ","version":"Next","tagName":"h2"},{"title":"üìò What is an Aggregation Pipeline?","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/what-is-aggregation/what-is-aggregation","content":"üìò What is an Aggregation Pipeline? An aggregation pipeline is similar to unix commands connected using pipes. We can construct modular, composable processing pipelines. An aggregation pipeline consists of one or more stages that process documents: Each stage performs an operation on the input documents. For example, a stage can filter documents, group documents, and calculate values. The documents that are the output of a stage are passed as the input to the next stage. An aggregation pipeline can return results for groups of documents. For example, return the total, average, maximum, and minimum values, etc.","keywords":"","version":"Next"},{"title":"üëê $match","type":0,"sectionRef":"#","url":"/aggregation-pipeline-lab/docs/simple-queries/match","content":"","keywords":"","version":"Next"},{"title":"Expressions‚Äã","type":1,"pageTitle":"üëê $match","url":"/aggregation-pipeline-lab/docs/simple-queries/match#expressions","content":" The &lt;expression&gt; portion of the $match stage can be any valid MongoDB expression. This includes:  Comparison operators: eq, neq, gte, lte, gt, lt, in, nin, exists.Regular expressions: regex.Logical operators: and, or, not.Subdocuments and arrays: { field: &lt;value&gt; }, [ &lt;item&gt;, &lt;item&gt;, ... ].  ","version":"Next","tagName":"h2"},{"title":"Matching book documents‚Äã","type":1,"pageTitle":"üëê $match","url":"/aggregation-pipeline-lab/docs/simple-queries/match#matching-book-documents","content":" Atlas UIMongoDB Shell First, make sure you select the books collection in the Atlas UI. Then, navigate to the Aggregation tab and click &lt;/&gt; TEXT. Say we want all the books from the year 2010. We can add a $match stage to filter the documents from the books collection: [ { $match: { year: 2010 } } ]   üëê Return all the books that have exactly 100 pages.  Answer Atlas UIMongoDB Shell [ { $match: { pages: 100 } } ]   ","version":"Next","tagName":"h2"},{"title":"AND‚Äã","type":1,"pageTitle":"üëê $match","url":"/aggregation-pipeline-lab/docs/simple-queries/match#and","content":" If we need to add more conditions using AND, we use the $and operator.  If we want all the books with 100 pages and with exactly totalInventory 1, we can use the $and operator. It takes an array of documents with all the conditions that should be true for the AND to succeed:  Atlas UIMongoDB Shell [ { $match: { $and: [ { pages: 100 }, { totalInventory: 1 } ] } } ]   The pseudo-code for this would be something like:  IF pages == 100 AND totalInventory == 1 { return matching docs }   üëê Return all the books from 2009 that have exactly 192 pages.  Answer Atlas UIMongoDB Shell [ { $match: { $and: [ { pages: 192 }, { year: 2009 } ] } } ]   üëê How many are there? We haven't yet seen the $count stage, but try to adding a second stage to your pipeline with { $count: &quot;books_count&quot; }  Answer Atlas UIMongoDB Shell [ { $match: { $and: [ { pages: 100 }, { year: 2015 } ] } }, { $count: &quot;books_count&quot; } ]   ","version":"Next","tagName":"h2"},{"title":"Shorthand AND‚Äã","type":1,"pageTitle":"üëê $match","url":"/aggregation-pipeline-lab/docs/simple-queries/match#shorthand-and","content":" We can do an implicit AND just passing a document with all the conditions (instead of an array of documents):  Atlas UIMongoDB Shell [ { $match: { pages: 100, totalInventory: 2 } } ]   üëê Return all the books from 2009 that have exactly 192 pages, using the shorthand $and notation:  Answer Atlas UIMongoDB Shell [ { $match: {pages: 192, year: 2009} } ]  ","version":"Next","tagName":"h3"}],"options":{"languages":["en","zh"],"id":"default"}}